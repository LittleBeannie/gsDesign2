[{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_AHR.html","id":"test-1-unstratified-population","dir":"Articles","previous_headings":"","what":"Test 1: unstratified population","title":"check AHR()","text":"","code":"enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001) x1 <- AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) x2 <- AHR_(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30))  expect_equal(x1, x2)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_AHR.html","id":"test-2-stratified-population","dir":"Articles","previous_headings":"","what":"Test 2: stratified population","title":"check AHR()","text":"","code":"enrollRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001)  x1 <- AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) x2 <- AHR_(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30))  expect_equal(x1, x2)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_eEvents_df.html","id":"test-1","dir":"Articles","previous_headings":"","what":"Test 1","title":"Check eEvents_df","text":"","code":"enrollRates <- tibble(duration = c(2, 1, 2), rate = c(5, 10, 20)) failRates <- tibble(duration = c(1, 1, 1),failRate = c(.05, .02, .01), dropoutRate = .01) totalDuration <- 20  x1 <- gsDesign::eEvents(lambda = failRates$failRate,                         S = failRates$duration[1 : (nrow(failRates) - 1)],                         eta = failRates$dropoutRate,                         gamma = enrollRates$rate,                         R = enrollRates$duration,                         T = totalDuration)$d  x2 <- eEvents_df_(enrollRates, failRates, totalDuration, simple = TRUE)  x3 <- eEvents_df(enrollRates, failRates, totalDuration, simple = TRUE)  tibble(method = c(\"gsDesign\", \"old version\", \"new version\"),        exp_events = c(x1, x2, x3)) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_eEvents_df.html","id":"test-2","dir":"Articles","previous_headings":"","what":"Test 2","title":"Check eEvents_df","text":"","code":"enrollRates <- tibble(duration = c(1, 1, 8), rate = c(3, 2, 0)) failRates <- tibble(duration = c(4, Inf), failRate = c(.03, .06), dropoutRate = c(.001, .002)) totalDuration <- 7  x <- eEvents_df(enrollRates, failRates, totalDuration, simple = FALSE) %>% data.frame() # expected checked with alternate calculations in gsSurvNPH vignette y <- data.frame(t = c(0, 4), failRate = c(0.03, 0.06), Events = c(0.5642911, 0.5194821))  x %>% gt() %>% tab_header(title = \"From gsDesign2 new version\") y %>% gt() %>% tab_header(title = \"From gsSurvNPH vignette\")"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"new-version","dir":"Articles","previous_headings":"Test 1: verify by gs_power_npe","what":"new version","title":"check of gs_design_npe","text":"power 0.9. re-use bounds alternate hypothesis, can get power close 0.9.","code":"x <- gs_design_npe(theta = c(.1, .2, .3), info = (1:3) * 40, beta = 0.1,                    upper = gs_spending_bound,                    upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                    lower = gs_spending_bound,                    lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)), binding = TRUE) x %>% gt() gs_power_npe(theta = c(.1, .2, .3),info = (1:3) * 40,              upper = gs_b, upar = list(par = (x %>% filter(Bound == \"Upper\"))$Z),              lower = gs_b, lpar = list(par = -(x %>% filter(Bound == \"Upper\"))$Z),              binding = TRUE # Always use binding = TRUE for power calculations              ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"old-version","dir":"Articles","previous_headings":"Test 1: verify by gs_power_npe","what":"old version","title":"check of gs_design_npe","text":"power 0.9. re-use bounds alternate hypothesis, can get power close 0.9.","code":"x <- gs_design_npe_(theta = c(.1, .2, .3), info = (1:3) * 40, beta = 0.1,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL), binding = TRUE) x %>% gt() gs_power_npe_(theta = c(.1, .2, .3),info = (1:3) * 40,              upper = gs_b, upar = (x %>% filter(Bound == \"Upper\"))$Z,              lower = gs_b, lpar = -(x %>% filter(Bound == \"Upper\"))$Z,              binding = TRUE # Always use binding = TRUE for power calculations              ) %>% gt()"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"difference-of-proportions","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"difference of proportions","title":"check of gs_design_npe","text":"","code":"# Lachin book p71  pc <- .28            # Control response rate pe <- .40            # Experimental response rate p0 <- (pc + pe) / 2  # Ave response rate under H0  # Information per increment of 1 in sample size info0 <- 1 / (p0 * (1 - p0) * 4) info <- 1 / (pc * (1 - pc) * 2 + pe * (1 - pe) * 2)  # Result should round up to next even number = 652 # Divide information needed under H1 by information per patient added x1_a <- gs_design_npe(theta = pe - pc, info = info, info0 = info0, info_scale = 0) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_design_npe(theta = pe - pc, info = info, info0 = info0, info_scale = 1) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_design_npe(theta = pe - pc, info = info, info0 = info0, info_scale = 2) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = pe - pc, info = info, info0 = info0) %>% mutate(`Computated from` = \"old version\")"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"info-info0-info1","dir":"Articles","previous_headings":"Test 1: examples in spec > fixed design","what":"info = info0 = info1","title":"check of gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 80, info_scale = 0,                       upper = gs_b, upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),                       lower = gs_b, lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 80, info_scale = 1,                       upper = gs_b, upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),                       lower = gs_b, lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 80, info_scale = 2,                       upper = gs_b, upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),                       lower = gs_b, lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2) x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 80,                      upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"info-info0-info1-1","dir":"Articles","previous_headings":"Test 1: examples in spec > fixed design","what":"info != info0 != info1","title":"check of gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 80 + 10, info1 = (1:3) * 70 - 2, info_scale = 0,                       upper = gs_b, upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),                       lower = gs_b, lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 80 + 10, info1 = (1:3) * 70 - 2, info_scale = 1,                       upper = gs_b, upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),                       lower = gs_b, lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 80 + 10, info1 = (1:3) * 70 - 2, info_scale = 2,                       upper = gs_b, upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),                       lower = gs_b, lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2) x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 80 + 10, info1 = (1:3) * 70 - 2,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"futility-at-ia1-efficacy-only-at-ia2-fa","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"futility at IA1; efficacy only at IA2 +FA","title":"check of gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 40, info_scale = 0,                       upper = gs_spending_bound, upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_b, lpar = list(par = c(-1, -Inf, -Inf)),                       test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0)  x1_b <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 40, info_scale = 1,                       upper = gs_spending_bound, upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_b, lpar = list(par = c(-1, -Inf, -Inf)),                       test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1)  x1_c <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 40, info_scale = 2,                       upper = gs_spending_bound, upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_b, lpar = list(par = c(-1, -Inf, -Inf)),                       test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = c(.1, .2, .3),                     info = (1:3) * 40, info0 = (1:3) * 40,                      upper = gs_spending_bound, upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_b, lpar =  c(-1, -Inf, -Inf),                     test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"old version\", `Info scale` = 0) x1_a %>%    union_all(x1_b) %>%    union_all(x1_c) %>%    union_all(x2) %>%    arrange(Analysis) %>%    group_by(Analysis, Bound) %>%    gt() %>%    tab_style(     style = list(cell_fill(color = \"#d3edeb\")),     locations = cells_body(rows = `Computated from` == \"old version\"))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"spending-bounds","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"spending bounds","title":"check of gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 40, info0 = (1:3) * 50, info_scale = 0,                       upper = gs_spending_bound,                       upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_spending_bound,                       lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0)  x1_b <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 40, info0 = (1:3) * 50, info_scale = 1,                       upper = gs_spending_bound,                       upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_spending_bound,                       lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1)  x1_c <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 40, info0 = (1:3) * 50, info_scale = 2,                       upper = gs_spending_bound,                       upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_spending_bound,                       lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 50,                       upper = gs_spending_bound,                      upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                      lower = gs_spending_bound,                      lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"sided-symmetric-spend","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"2-sided symmetric spend","title":"check of gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info_scale = 0,                       binding = TRUE,                       upper = gs_spending_bound,                       upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_spending_bound,                       lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0)  x1_b <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info_scale = 1,                       binding = TRUE,                       upper = gs_spending_bound,                       upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_spending_bound,                       lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1)  x1_c <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info_scale = 2,                       binding = TRUE,                       upper = gs_spending_bound,                       upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                       lower = gs_spending_bound,                       lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 40,                        binding = TRUE,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"default","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Default","title":"Check gs_power_npe","text":"default gs_power_npe single analysis type error controlled.","code":"x1 <- gs_power_npe(theta = 0) %>% filter(Bound == \"Upper\") x2 <- gsDesign2:::gs_power_npe_(theta = 0) %>% filter(Bound == \"Upper\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"fixed-bound","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Fixed bound","title":"Check gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = c(.1, .2, .3),                    info = (1:3) * 40,                    upper = gs_b,                    upar = list(par = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound),                    lower = gs_b,                    lpar = list(par = c(-1, 0, 0))) %>% mutate(`Computated from` = \"new version\")  x2 <- gsDesign2:::gs_power_npe_(theta = c(.1, .2, .3),                                 info = (1:3) * 40,                                 upper = gs_b,                                 upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,                                 lower = gs_b,                                 lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"same-fixed-efficacy-bounds-no-futility-bound-i-e--non-binding-bound-null-hypothesis","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Same fixed efficacy bounds, no futility bound (i.e., non-binding bound), null hypothesis","title":"Check gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = rep(0, 3),                    info = (1:3) * 40,                    upar = list(par = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound),                    lpar = list(par = rep(-Inf, 3))) %>% mutate(`Computated from` = \"new version\")  x2 <- gsDesign2:::gs_power_npe_(theta = rep(0, 3),                                 info = (1:3) * 40,                                 upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,                                 lpar = rep(-Inf, 3)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"fixed-bound-with-futility-only-at-analysis-1-efficacy-only-at-analyses-2-3","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Fixed bound with futility only at analysis 1; efficacy only at analyses 2, 3","title":"Check gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = c(.1, .2, .3),                    info = (1:3) * 40,                    upper = gs_b,                    upar = list(par = c(Inf, 3, 2)),                    lower = gs_b,                    lpar = list(par = c(qnorm(.1), -Inf, -Inf))) %>% mutate(`Computated from` = \"new version\")  x2 <- gsDesign2:::gs_power_npe_(theta = c(.1, .2, .3),                                 info = (1:3) * 40,                                 upper = gs_b,                                 upar = c(Inf, 3, 2),                                 lower = gs_b,                                 lpar = c(qnorm(.1), -Inf, -Inf)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"spending-function-bounds","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Spending function bounds","title":"Check gs_power_npe","text":"","code":"# Lower spending based on non-zero effect x1 <- gs_power_npe(theta = c(.1, .2, .3),                    info = (1:3) * 40,                    upper = gs_spending_bound,                    upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                    lower = gs_spending_bound,                    lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) %>% mutate(`Computated from` = \"new version\")  x2 <- gsDesign2:::gs_power_npe_(theta = c(.1, .2, .3),                                 info = (1:3) * 40,                                 upper = gs_spending_bound,                                 upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                                 lower = gs_spending_bound,                                 lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"same-bounds-but-power-under-different-theta","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Same bounds, but power under different theta","title":"Check gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = c(.15, .25, .35),                    info = (1:3) * 40,                    upper = gs_spending_bound,                    upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                    lower = gs_spending_bound,                    lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) %>% mutate(`Computated from` = \"new version\")  x2 <- gsDesign2:::gs_power_npe_(theta = c(.15, .25, .35),                                 info = (1:3) * 40,                                 upper = gs_spending_bound,                                 upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                                 lower = gs_spending_bound,                                 lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"two-sided-symmetric-spend-obrien-fleming-spending","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Two-sided symmetric spend, O’Brien-Fleming spending","title":"Check gs_power_npe","text":"Typically, 2-sided bounds binding","code":"x1 <- gs_power_npe(theta = rep(0, 3),                    info = (1:3) * 40,                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),                    lower = gs_spending_bound,                    lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))) %>% mutate(`Computated from` = \"new version\")  x2 <- gsDesign2:::gs_power_npe_(theta = rep(0, 3),                                  info = (1:3) * 40,                                 binding = TRUE,                                 upper = gs_spending_bound,                                 upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                                 lower = gs_spending_bound,                                 lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"re-use-these-bounds-under-alternate-hypothesis","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Re-use these bounds under alternate hypothesis","title":"Check gs_power_npe","text":"Always use binding = TRUE power calculations","code":"xx1 <- gs_power_npe(theta = c(.1, .2, .3),                      info = (1:3) * 40,                     binding = TRUE,                     upar = list(par = (x1 %>% filter(Bound == \"Upper\"))$Z),                     lpar = list(par = -(x1 %>% filter(Bound == \"Upper\"))$Z)) %>% mutate(`Computated from` = \"new version\")  xx2 <- gsDesign2:::gs_power_npe_(theta = c(.1, .2, .3),                                   info = (1:3) * 40,                                  binding = TRUE,                                  upar = (x1 %>% filter(Bound == \"Upper\"))$Z,                                  lpar = -(x1 %>% filter(Bound == \"Upper\"))$Z) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"test-2-fixed-design","dir":"Articles","previous_headings":"","what":"Test 2: Fixed Design","title":"Check gs_power_npe","text":"power following analysis expected 0.975.","code":"gs_power_npe(theta = 0,               upper = gs_b, upar = list(par = qnorm(0.025)),              lower = gs_b, lpar = list(par = -Inf)) ## # A tibble: 1 × 10 ##   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 ##      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1 Upper -1.96       0.975     0      0     1     1     1     1"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"test-3-spending-fucntions","dir":"Articles","previous_headings":"","what":"Test 3: Spending fucntions","title":"Check gs_power_npe","text":"one inputs info upar one inputs info lpar","code":"gs_power_npe(theta = 0,               info = 50,              upper = gs_spending_bound,               upar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025),                          info = 60),              lower = gs_b,               lpar = list(par = -Inf)) %>% gt() gs_power_npe(theta = 0,               info = 50,              info0 = 70,              upper = gs_spending_bound,               upar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025),                          info = 60),              lower = gs_b,               lpar = list(par = -Inf)) %>% gt() gs_power_npe(theta = 0,               info = 50,              upper = gs_b,               upar = list(par = qnorm(0.025)),              lower = gs_spending_bound,               lpar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.1),                           info = 40)) %>% gt() gs_power_npe(theta = 0,               info = 50,              info1 = 30,              upper = gs_b,               upar = list(par = qnorm(0.025)),              lower = gs_spending_bound,               lpar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.1),                           info = 40)) %>% gt()"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"sided-test","dir":"Articles","previous_headings":"Test 3: Developer Tests","what":"1-sided test","title":"Check gs_power_npe","text":"","code":"x <- gs_power_npe(theta = .1,                    info = (1:3) * 400,                    binding = FALSE,                   upper = gs_spending_bound,                    upar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025)),                   lower = gs_b,                    lpar = list(par = rep(-Inf, 3))) %>% filter(Bound == \"Upper\")  y <- gsDesign2:::gs_power_npe_(theta = .1,                    info = (1:3) * 400,                    binding = FALSE,                   upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025),                   lower = gs_b,                    lpar = rep(-Inf, 3)) %>% filter(Bound == \"Upper\")  z <- gsProbability(k = 3,                     theta = .1,                     n.I = (1:3) * 400,                     b = gsDesign(k = 3, test.type = 1, sfu = sfLDOF)$upper$bound, a = rep(-20, 3))"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"expect-equal-with-mvtnorm-for-efficacy-and-futility-bounds","dir":"Articles","previous_headings":"Test 4: Independent Tests","what":"Expect equal with mvtnorm for efficacy and futility bounds","title":"Check gs_power_npe","text":"","code":"info <- c(40, 100) r <- info[1] / info[2]  test<-gs_power_npe(theta = 0,                    info = info,                    info0 = NULL,                    binding = FALSE,                    upper = gs_spending_bound,                    upar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025)),                    lower = gs_spending_bound,                    lpar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.02)) )  test1 <- test%>% filter(Bound == \"Upper\") test2 <- test%>% filter(Bound == \"Lower\")  alpha.t <- 0.025 b.ia <- gsDesign::sfLDOF(alpha = alpha.t, t = r) alpha.ia <- b.ia$spend  Pb <- function(alpha.t, alpha.ia, r, b){   temp = mvtnorm::pmvnorm(lower = c(-Inf, b),                            upper = c(qnorm(1-alpha.ia), Inf),                           corr = rbind(c(1, sqrt(r)), c(sqrt(r), 1)))   return(alpha.t - alpha.ia - temp) }  b <- uniroot(Pb, c(1.96, 4), alpha.t = alpha.t, alpha.ia = alpha.ia, r = r)  pb <- 1- pnorm(b$root)  expect_equal(object = test1$Z, expected = c(qnorm(1-alpha.ia),b$root), tolerance = 0.001) expect_equal(object = test1$Probability, expected = cumsum(c(b.ia$spend,pb)), tolerance = 0.001)    beta.t <- 0.02   a.ia <- gsDesign::sfLDOF(alpha = beta.t, t = r)   beta.ia <- a.ia$spend    Pa <- function(beta.t, beta.ia,  r, a){     temp <- mvtnorm::pmvnorm(lower = c(-Inf, qnorm(beta.ia)),                              upper = c(a, Inf),                              corr = rbind(c(1, sqrt(r)), c(sqrt(r), 1)))     return(beta.t -  beta.ia - temp)   }    a <- uniroot(Pa, c(-4, 1.96), beta.t = beta.t, beta.ia = beta.ia, r = r)    pa <- pnorm(a$root)    expect_equal(object = test2$Z, expected = c(qnorm(beta.ia), a$root), tolerance = 0.001)   expect_equal(object = test2$Probability, expected = cumsum(c(a.ia$spend,pa)), tolerance = 0.001)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"expect-equal-with-gsdesigngsprobability-outcome-for-efficacy-bounds","dir":"Articles","previous_headings":"Test 4: Independent Tests","what":"Expect equal with gsDesign::gsProbability outcome for efficacy bounds","title":"Check gs_power_npe","text":"","code":"info <- c(40, 150, 200)  x <- gs_power_npe(theta = .1,                   info = info, binding = FALSE,                   upper = gs_spending_bound,                   upar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025)),                   lower = gs_b,                   lpar = list(par = rep(-Inf, 3))) %>% filter(Bound == \"Upper\")  y <- gs_power_npe(theta = .1,                   info = info, binding = FALSE,                   upper = gs_spending_bound,                   upar = list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025)),                   lower = gs_b,                   lpar = list(par = rep(-Inf, 3))) %>% filter(Bound == \"Upper\")  z <- gsDesign::gsProbability(k = 3, theta = .1,                              n.I = info,                              a = rep(-20, 3),                              b = gsDesign(k = 3, test.type=1, sfu = sfLDOF, n.I = info)$upper$bound)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"test-5-compare-with-gsdesign-under-information-based-design","dir":"Articles","previous_headings":"","what":"Test 5: Compare with gsDesign under information-based design","title":"Check gs_power_npe","text":"Information-based design useful testing natural parameter \\(\\delta\\) (e.g., treatment difference relevant scale risk difference) variance estimate \\(\\delta\\) unknown. basic canonical form (???) represents information-based design, particularly simple way check corresponding basic calculations sample size, bounds power gs_power_npe() gs_design_npe().","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"step-1-set-the-design-assumptions","dir":"Articles","previous_headings":"Test 5: Compare with gsDesign under information-based design","what":"Step 1: set the design assumptions","title":"Check gs_power_npe","text":"","code":"k <- 2           # Number of analyses test.type <- 4 alpha <- 0.025   # 1-sided Type I error beta <- 0.15     # Type 2 error (1 - targeted power) astar <- .1 timing <- 0.4    # Timing (information fraction) at interim analyses sfu <- sfHSD     # Efficacy bound spending function sfupar <- -1     # Upper bound spending function parameters, if any sfl <- sfLDPocock# Lower bound spending function, if used (test.type > 2) sflpar <- 0      # Lower bound spending function parameters, if any delta <- 0.1     # Natural parameter difference (assumed value - H0 value) delta1 <- 0.1    # Natural parameter assumed value delta0 <- 0      # Natural parameter difference under H0 endpoint <- 'info' n.fix <- 0"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_tEvents.html","id":"test-1","dir":"Articles","previous_headings":"","what":"Test 1","title":"Check tEvents","text":"test, verify tEvents() AHR().","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x <- AHR(enrollRates = enrollRates, failRates = failRates,           ratio = ratio, totalDuration = 20) cat(\"The number of events by 20 months is \", x$Events, \".\\n\") ## The number of events by 20 months is  208.3641 . y <- tEvents(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, targetEvents = x$Events)  cat(\"The time to get \", x$Events, \" is \", y$Time, \"months.\\n\") ## The time to get  208.3641  is  20 months."},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_tEvents.html","id":"test-2","dir":"Articles","previous_headings":"","what":"Test 2","title":"Check tEvents","text":"","code":"x1 <- tEvents() x2 <- gsDesign2:::tEvents_()  x1 %>%    union_all(x2) %>%    mutate(`function comes from` = c(\"new version\", \"old version\")) %>%    select(`function comes from`, Time, AHR, Events, info, info0) ## # A tibble: 2 × 6 ##   `function comes from`  Time   AHR Events  info info0 ##   <chr>                 <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1 new version            14.9 0.787   150.  36.9  37.5 ## 2 old version            14.9 0.787   150.  36.9  37.5"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_tEvents.html","id":"test-3","dir":"Articles","previous_headings":"","what":"Test 3","title":"Check tEvents","text":"","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x1 <- tEvents(enrollRates = enrollRates, failRates = failRates, ratio = ratio, targetEvents = 200) x2 <- gsDesign2:::tEvents_(enrollRates = enrollRates, failRates = failRates, ratio = ratio, targetEvents = 200)  x1 %>%    union_all(x2) %>%    mutate(`function comes from` = c(\"new version\", \"old version\")) %>%    select(`function comes from`, Time, AHR, Events, info, info0) ## # A tibble: 2 × 6 ##   `function comes from`  Time   AHR Events  info info0 ##   <chr>                 <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1 new version            19.2 0.744   200.  48.9  50.0 ## 2 old version            19.2 0.744   200.  48.9  50.0"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"introduction-of-ahr","dir":"Articles","previous_headings":"","what":"Introduction of AHR()","title":"Usage of AHR","text":"AHR() provides geometric average hazard ratio various non-proportional hazards assumptions either single multiple strata studies. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"example-1-un-stratified-population","dir":"Articles","previous_headings":"Usage of AHR()","what":"Example 1: Un-stratified population","title":"Usage of AHR","text":"","code":"enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001) AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) ## # A tibble: 2 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    15 0.694   91.0  22.6  22.7 ## 2    30 0.685  154.   37.9  38.6"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"example-2-stratified-population","dir":"Articles","previous_headings":"Usage of AHR()","what":"Example 2: Stratified population","title":"Usage of AHR","text":"","code":"enrollRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001) AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) ## # A tibble: 2 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    15 0.733   113.  28.1  28.3 ## 2    30 0.718   166.  41.3  41.5"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"inner-logic-of-ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of AHR()","title":"Usage of AHR","text":"Let’s take un-stratified population example, enrollment rate, failure rates dropout rates Step 1: compute proportion group compute expected events different treatment group, stratum time period, iterate totalDuration Strata. Since example, one analysis time (totalDuration = 30) one stratum (Stratum = \"\"), iterate . one multiple analysis time strata, one can use loop bind results row. Step 2: subset enrollment rates failure rates stratum. Step 3: calculate enrollment rates experimental arm control arm, respectively. Step 4: update failure rate control experimental arm. Step 5: calculate expected number events control experimental eEvents_df(). t column start period, failRate column failure rate period, Events column expected events period. Step 6: combine results together output . Please note , output, info column based following input. alternative hypothesis \\(H_1\\) \\[   \\text{hr}   =   \\left\\{   \\begin{array}{ll}     0.9  & \\text{first 1 month} \\\\     0.75 & \\text{afterwards},   \\end{array}   \\right. \\] info = info1, info1 statistical information \\(H_1\\). notice enrollRates failRates always \\(H_1\\), call info, rather info1.","code":"enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4),                       rate = c(5, 10, 0)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2),                     hr = c(.9, .75),                     dropoutRate = .001)  ratio <- 2  totalDuration <- 30 Qe <- ratio / (1 + ratio) Qc <- 1 - Qe ## The proportion of the experimental arm is  0.6666667 ## The proportion of the control arm is  0.3333333 td <- totalDuration s <- \"All\" enroll <- enrollRates %>% filter(Stratum == s) fail <- failRates %>% filter(Stratum == s) enroll_c <- enroll %>% mutate(rate = rate * Qc) enroll_e <- enroll %>% mutate(rate = rate * Qe) fail_c <- fail fail_e <- fail %>% mutate(failRate = failRate * hr) events_c <- eEvents_df(enrollRates = enroll_c, failRates = fail_c, totalDuration = td, simple = FALSE) events_e <- eEvents_df(enrollRates = enroll_e, failRates = fail_e, totalDuration = td, simple = FALSE) ## The expected number of events in the control arm is ## # A tibble: 3 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0      0.1   3.49 ## 2     1      0.2  30.6  ## 3     2      0.2   1.98 ## The expected number of events in the experimental arm is ## # A tibble: 3 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0     0.09   6.31 ## 2     1     0.15  57.2  ## 3     2     0.15   6.86 # combine control and experimental events <- rbind(events_c %>% mutate(Treatment = \"Control\"),                 events_e %>% mutate(Treatment = \"Experimental\")) %>%           arrange(t, Treatment) %>%            ungroup() %>%            # recompute HR, events, info by period           group_by(t) %>%           summarize(Stratum = s,                      info = (sum(1 / Events))^(-1),                     Events = sum(Events),                      HR = last(failRate) / first(failRate)) %>%            # compute info0           mutate(Time = td,                   lnhr = log(HR),                   info0 = Events * Qc * Qe) %>%           ungroup() %>%                       group_by(Time, Stratum, HR) %>%           summarize(t = min(t),                      Events = sum(Events),                      info0 = sum(info0),                      info = sum(info)) %>%           # pool time period together           group_by(Time) %>%           summarize(AHR = exp(sum(log(HR) * Events) / sum(Events)),                     Events = sum(Events),                     info = sum(info),                     info0 = sum(info0)) ## The overall expected number of events over the time is ## # A tibble: 1 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    30 0.763   106.  23.7  23.6 enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4),                       rate = c(5, 10, 0)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2),                     hr = c(.9, .75),                     dropoutRate = .001)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"introduction-of-eevents_df","dir":"Articles","previous_headings":"","what":"Introduction of eEvents_df","title":"Usage of eEvents_df","text":"eEvents_df() computes expected number events given analysis time strata assumption piecewise model: piecewise constant enrollment rates piecewise exponential failure rates piecewise censoring rates. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time. df eEvents_df() short data frame, since output data frame.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-1-single-enroll-single-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 1: Single Enroll + Single Fail Period","title":"Usage of eEvents_df","text":"","code":"enrollRates <- tibble(duration = 10, rate = 10) failRates <- tibble(duration = 100, failRate = log(2) / 6, dropoutRate = .01) totalDuration <- 22  eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE) ## # A tibble: 1 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0    0.116   80.4"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-2-multiple-enroll-single-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 2: Multiple Enroll + Single Fail Period","title":"Usage of eEvents_df","text":"","code":"enrollRates <- tibble(duration = c(5, 5), rate = c(10, 20)) failRates <- tibble(duration = 100, failRate = log(2)/6, dropoutRate = .01) totalDuration <- 22  eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE) ## # A tibble: 1 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0    0.116   119."},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-3-signle-enroll-multiple-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 3: Signle Enroll + Multiple Fail Period","title":"Usage of eEvents_df","text":"","code":"enrollRates <- tibble(duration = 10, rate = 10) failRates <- tibble(duration = c(20, 80), failRate = c(log(2)/6, log(2)/4), dropoutRate = .01) totalDuration <- 22  eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE) ## # A tibble: 2 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0    0.116 80.2   ## 2    20    0.173  0.250"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-4-multiple-duration","dir":"Articles","previous_headings":"Use Cases","what":"Example 4: Multiple Duration","title":"Usage of eEvents_df","text":"","code":"enrollRates <- tibble(duration = 10, rate = 10) failRates <- tibble(duration = 100, failRate = log(2) / 6, dropoutRate = .01) totalDuration <- c(2, 22)  try(eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE)) ## Error in if (last(cumsum(failRates$duration)) < totalDuration) { :  ##   the condition has length > 1"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"inner-logic-of-eevents_df","dir":"Articles","previous_headings":"","what":"Inner Logic of eEvents_df()","title":"Usage of eEvents_df","text":"Step 1: set analysis time. Step 2: set enrollment rates.  Step 3: set failure rates dropout rates.   Given piecewise enrollment rates, failure rates, dropout rates, time line divided several parts: \\((0, 5]\\) (5 change point enrollment rates); \\((5, 10]\\) (10 another change point enrollment rates); \\((10, 20]\\) (20 change point failure rates); \\((20, 50]\\) (50 analysis time); \\((50, \\infty]\\) (analysis time).  Given sub-intervals, objective calculate expected number events sub-intervals. Step 4: divide time line enrollments Step 5: divide time line failure & dropout rates df_2, one needs discriminate analysis time (totalDuration = 50) beyond total failure rate duration. Step 6: divide time line considering change points enrollment, failure, dropout rates. find lots NA, can imputed piecewise model. Step 7: compute expected number events sub-intervals following technical details vignette ``computing expected events interval risk’’ Step 8: output results","code":"totalDuration <- 50 enrollRates <- tibble(duration = c(5, 5), rate = c(10, 20))  # create a step function (sf) to define enrollment rates over time sf.enrollRate <- stepfun(c(0, cumsum(enrollRates$duration)),                          c(0, enrollRates$rate, 0),                          right = FALSE)  plot(sf.enrollRate,       xlab = \"duration\", ylab = \"enrollment rates\",       main = \"Piecewise enrollment rate over time\", xlim = c(-0.01, 21)) failRates <- tibble(duration = c(20, 80), failRate = c(0.1, 0.2), dropoutRate = .01)  # get the time points where the failure rates change startFail <- c(0, cumsum(failRates$duration))  # plot the piecewise failure rates sf.failRate <- stepfun(startFail,                        c(0, failRates$failRate, last(failRates$failRate)),                        right = FALSE) plot(sf.failRate,       xlab = \"duration\", ylab = \"failure rates\",       main = \"Piecewise failure rate over time\", xlim = c(-0.01, 101)) # plot the piecewise dropout rate sf.dropoutRate <- stepfun(startFail,                           c(0, failRates$dropoutRate, last(failRates$dropoutRate)),                           right = FALSE) plot(sf.dropoutRate,       xlab = \"duration\", ylab = \"dropout rates\",       main = \"Piecewise dropout rate over time\", xlim = c(-0.01, 101)) df_1 <- tibble(startEnroll = c(0, cumsum(enrollRates$duration)),                endFail = totalDuration - startEnroll,                rate = c(enrollRates$rate, 0)) df_2 <- tibble(endFail = cumsum(failRates$duration),                startEnroll = totalDuration - endFail,                failRate = failRates$failRate,                dropoutRate = failRates$dropoutRate) # if the analysis time is after the total failure rate duration if(sum(failRates$duration) < totalDuration){   df_2 <- df_2[-nrow(df_2), ] }else{   df_2 <- df_2 %>% filter(startEnroll > 0) } df <- full_join(df_1, df_2, by = c(\"startEnroll\", \"endFail\")) %>% arrange(endFail) df <- df %>% mutate(endEnroll = lag(startEnroll, default = as.numeric(totalDuration)),                     startFail = lag(endFail, default = 0),                     duration = endEnroll - startEnroll,                     failRate = sf.failRate(startFail),                     dropoutRate = sf.dropoutRate(startFail),                     enrollRate = sf.enrollRate(startEnroll)) %>%               select(-rate) # create 2 auxiliary variable for failure & dropout rate              # q: number of expected events in a sub-interval              # Q: cumulative product of q (pool all sub-intervals) df <- df %>% mutate(q = exp(-duration * (failRate + dropoutRate)),                     Q = lag(cumprod(q), default = 1)) %>%              arrange(desc(startFail)) %>%              # create another 2 auxiliary variable for enroll rate              # g: number of expected subjects in a sub-interval              # G: cumulative sum of g (pool all sub-intervals)              mutate(g = enrollRate * duration,                     G = lag(cumsum(g), default = 0)) %>%              arrange(startFail) %>%              # compute expected events as nbar in a sub-interval              mutate(d = ifelse(failRate == 0, 0, Q * (1 - q) * failRate / (failRate + dropoutRate)),                     nbar = ifelse(failRate == 0, 0, G * d + (failRate * Q * enrollRate) / (failRate + dropoutRate) * (duration - (1 - q) / (failRate + dropoutRate)))) sf.startFail <- stepfun(startFail, c(0, startFail), right = FALSE) df <- df %>%    transmute(t = endFail, failRate = failRate, Events = nbar, startFail = sf.startFail(startFail)) %>%    group_by(startFail) %>%   summarize(failRate = first(failRate), Events = sum(Events)) %>%   mutate(t = startFail) %>%    select(\"t\", \"failRate\", \"Events\")  df %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"introduction-of-gs_b","dir":"Articles","previous_headings":"","what":"Introduction of gs_b()","title":"Usage of gs_b","text":"gs_b() can used derive fixed boundary fixed/group sequential design. usually used upper = ... lower = ... arguments + gs_power_npe() + gs_design_npe() + gs_power_ahr() + gs_design_ahr() + gs_power_wlr() + gs_design_wlr() + gs_power_combo() + gs_design_combo()","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"example-1","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 1","title":"Usage of gs_b","text":"Assume group sequential design 3 analysis, one can input upper bound vector c(4, 3, 2) using gs_b() follows.","code":"gs_b(par = 4:2) ## [1] 4 3 2"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"example-2","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 2","title":"Usage of gs_b","text":"example, one can assign upper bound second analysis ","code":"gs_b(par = 4:2, k = 2) ## [1] 3"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"example-3","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 3","title":"Usage of gs_b","text":"Generate efficacy bound using spending function. Use Lan-DeMets spending approximation O’Brien-Fleming bound 50%, 75% 100% final spending","code":"# information fraction IF <- c(.5, .75, 1) # Lan-DeMets spending approximation of O'Brien-Fleming par <- gsDesign::gsDesign(alpha = .025, k = length(IF),                            test.type = 1, sfu = gsDesign::sfLDOF,                            timing = IF)$upper$bound gs_b(par = par) ## [1] 2.962588 2.359018 2.014084"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"inner-logic-of-gs_b","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_b()","title":"Usage of gs_b","text":"gs_b short function 2 key arguments: par = ... k = ...","code":"if(is.null(k)){   return(par) }else{    return(par[k]) }"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"introduction-of-gs_info_ahr","dir":"Articles","previous_headings":"","what":"Introduction of gs_info_ahr()","title":"Usage of gs_info_ahr","text":"tEvents() calculate analysis time (Time output), number events (Events output), average hazard ratio (AHR outputs), effect size (theta output), statistical information (info info0 output) using average hazard ratio model. aforementioned calculation based piecewise model: + piecewise constant enrollment rates + piecewise exponential failure rates + piecewise censoring rates.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"example-1","dir":"Articles","previous_headings":"Use Cases","what":"Example 1","title":"Usage of gs_info_ahr","text":"example, input target number events events = ..., derive time events arrived.","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  gs_info_ahr(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, events = c(50, 80, 100)) ## # A tibble: 3 × 7 ##   Analysis  Time Events   AHR theta  info info0 ##      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1  8.29   50.0 0.850 0.163  12.4  12.5 ## 2        2 10.5    80.0 0.825 0.193  19.7  20.0 ## 3        3 11.9   100.  0.812 0.208  24.6  25.0"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"example-2","dir":"Articles","previous_headings":"Use Cases","what":"Example 2","title":"Usage of gs_info_ahr","text":"example, input analysis time analysisTimes = ..., derive number events analysis time.","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  gs_info_ahr(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, analysisTimes = c(10, 15, 20)) ## # A tibble: 3 × 7 ##   Analysis  Time Events   AHR theta  info info0 ##      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1    10   72.4 0.831 0.186  17.9  18.1 ## 2        2    15  151.  0.786 0.241  37.2  37.8 ## 3        3    20  208.  0.738 0.304  51.0  52.1"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"example-3","dir":"Articles","previous_headings":"Use Cases","what":"Example 3","title":"Usage of gs_info_ahr","text":"example, input analysisTimes = ... events = .... case, one see + derived analysis time (Time column) \\(\\geq\\) input analysisTimes + derived number event (Events column) \\(\\geq\\) input events","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  gs_info_ahr(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, analysisTimes = c(10, 15, 20), events = c(80,  # > events in example 2                                                                       140, # < > events in example 2                                                                       220  # > events in example 2                                                                       )) ## # A tibble: 3 × 7 ##   Analysis  Time Events   AHR theta  info info0 ##      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1  10.5   80.0 0.825 0.193  19.7  20.0 ## 2        2  15    151.  0.786 0.241  37.2  37.8 ## 3        3  21.2  220.  0.730 0.315  53.8  55.0"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"inner-logic-of-gs_info_ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_info_ahr()","title":"Usage of gs_info_ahr","text":"explain inner logic gs_info_ahr(), discuss 3 scenario. input analysisTimes input events input analysisTimes events","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"scenario-1-only-input-analysistimes","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 1: only input analysisTimes","title":"Usage of gs_info_ahr","text":"analysisTimes = ... input, essentially, gs_info_ahr() uses AHR() calculate number events analysisTimes. exactly output gs_info_ahr():","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 analysisTimes <- c(10, 15, 20)  AHR(enrollRates = enrollRates, failRates = failRates,      ratio = ratio, totalDuration = analysisTimes) %>%    mutate(theta = -log(AHR), Analysis = 1 : length(analysisTimes)) %>%    select(Analysis, Time, Events, AHR, theta, info, info0) %>%    gt() gs_info_ahr(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, analysisTimes = analysisTimes) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"scenario-2-only-input-events","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 2: only input events","title":"Usage of gs_info_ahr","text":"events = ... input, essentially, gs_info_ahr() uses tEvents() calculate time events arrived. exactly output gs_info_ahr():","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 events <- c(70, 150, 200)  ans <- NULL for(i in seq_along(events)){   ans_new <- gsDesign2::tEvents(enrollRates = enrollRates, failRates = failRates,                                  ratio = ratio, targetEvents = events[i])   ans <- rbind(ans, ans_new) }  ans %>%    mutate(theta = -log(AHR), Analysis = 1 : length(analysisTimes)) %>%    select(Analysis, Time, Events, AHR, theta, info, info0) %>%    gt() gs_info_ahr(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, events = events) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"scenario-3-both-input-analysistimes-and-events","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 3: both input analysisTimes and events","title":"Usage of gs_info_ahr","text":"analysisTimes = ... events = ... input, gs_info_ahr() uses AHR() tEvents(). way, guaranteed + derived number event (Events column) \\(\\geq\\) input events + derived analysis time (Time column) \\(\\geq\\) input analysisTimes exactly output gs_info_ahr():","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 analysisTimes <- c(10, 15, 20) events <- c(70, 150, 200)  ans <- NULL  # first, use `AHR()` to calculate the number of events at the input `analysisTimes` ans <- AHR(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, totalDuration = analysisTimes)  # second, compare if the events derived above meet the targeted number of events input in `events` for(i in seq_along(events)){   if (ans$Events[i] < events[i]){     ans[i,] <- tEvents(enrollRates = enrollRates, failRates = failRates,                         ratio = ratio, targetEvents = events[i])   } }  ans %>%    mutate(theta = -log(AHR), Analysis = 1 : length(analysisTimes)) %>%    select(Analysis, Time, Events, AHR, theta, info, info0) %>%    gt() gs_info_ahr(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, events = events, analysisTimes = analysisTimes) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"introduction-of-gs_power_npe","dir":"Articles","previous_headings":"","what":"Introduction of gs_power_npe()","title":"Usage of gs_power_npe","text":"gs_power_npe() derives group sequential bounds boundary crossing probabilities design. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires + treatment effect (theta, theta1) + statistical information analysis (info, info0, info1) + method deriving bounds, fixed bounds spending (upper, upar, lower, lpar). routine enables two things available gsDesign package: non-constant effect, flexibility boundary selection.","code":""},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"no-futility-bound","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"no futility bound","title":"Usage of gs_power_npe","text":"","code":"# Same fixed efficacy bounds,  (i.e., non-binding bound), null hypothesis gs_power_npe(   theta = rep(0, 3),   info = (1:3) * 40,   upar = list(par = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound),   lpar = list(par = rep(-Inf, 3))) %>%   filter(Bound == \"Upper\") %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"with-futility-bound","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"with futility bound","title":"Usage of gs_power_npe","text":"","code":"# Fixed bound gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   upper = gs_b,   upar = list(par = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound),   lower = gs_b,   lpar = list(par = c(-1, 0, 0))) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"futility-only-at-analysis-1","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"futility only at analysis 1","title":"Usage of gs_power_npe","text":"","code":"gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   upper = gs_b,   upar = list(par = c(Inf, 3, 2)),   lower = gs_b,   lpar = list(par = c(qnorm(.1), -Inf, -Inf))) %>% gt()"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"lower-spending-based-on-non-zero-effect","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 2: spending bounds","what":"lower spending based on non-zero effect","title":"Usage of gs_power_npe","text":"","code":"gs_power_npe(   theta = c(.1, .2, .3), # non-zero effect   info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) ## # A tibble: 6 × 10 ##   Analysis Bound       Z Probability theta theta1    IF  info info0 info1 ##      <int> <chr>   <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1 Upper  3.71       0.00104   0.1    0.1 0.333    40    40    40 ## 2        2 Upper  2.51       0.235     0.2    0.2 0.667    80    80    80 ## 3        3 Upper  1.99       0.883     0.3    0.3 1       120   120   120 ## 4        1 Lower -1.36       0.0230    0.1    0.1 0.333    40    40    40 ## 5        2 Lower  0.0726     0.0552    0.2    0.2 0.667    80    80    80 ## 6        3 Lower  1.86       0.100     0.3    0.3 1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"sided-symmetric-spend","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 2: spending bounds","what":"2-sided symmetric spend","title":"Usage of gs_power_npe","text":"","code":"x <- gs_power_npe(   theta = rep(0, 3),   info = (1:3) * 40,   # typically, 2-sided bounds are binding   binding = TRUE,   upper = gs_spending_bound,   # O'Brien-Fleming spending   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)))  x %>% gt() # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upar = list(par = (x %>% filter(Bound == \"Upper\"))$Z),   lpar = list(par = -(x %>% filter(Bound == \"Upper\"))$Z)) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"inner-logic-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_spending_bound()","title":"Usage of gs_power_npe","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_spending_bound.html","id":"introduction-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Introduction of gs_spending_bound()","title":"Usage of gs_spending_bound","text":"gs_spending_bound() can used derive spending boundary group sequential design. usually used upper = ... lower = ... arguments + gs_power_npe() + gs_design_npe() + gs_power_ahr() + gs_design_ahr() + gs_power_wlr() + gs_design_wlr() + gs_power_combo() + gs_design_combo()","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_spending_bound.html","id":"example-1","dir":"Articles","previous_headings":"Usage of gs_spending_bound()","what":"Example 1","title":"Usage of gs_spending_bound","text":"","code":"info <- (1:3) * 10 IF <- info / max(info) k <- length(IF)  # 1st analysis a1 <- gs_spending_bound(k = 1, efficacy = FALSE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = NULL)  b1 <- gs_spending_bound(k = 1, efficacy = TRUE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = NULL) cat(\"The (lower, upper) boundary at the 1st analysis is (\", a1, \", \", b1, \").\\n\") ## The (lower, upper) boundary at the 1st analysis is ( -3.710303 ,  3.710303 ). # 2st analysis a2 <- gs_spending_bound(k = 2, efficacy = FALSE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = h1(r = 18, theta = 0,  I = info[1],  a = a1, b = b1))  b2 <- gs_spending_bound(k = 2, efficacy = TRUE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = h1(r = 18, theta = 0,  I = info[1],  a = a1, b = b1)) cat(\"The upper boundary at the 2nd analysis is (\", a2, \", \", b2, \").\\n\") ## The upper boundary at the 2nd analysis is ( -2.511434 ,  2.511434 ). # 3nd analysis # a3 <- gs_spending_bound(k = 2, efficacy = FALSE, theta = 0, #                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),  #                         hgm1 = hupdate(r = 18, theta = 0,  I = info[2],  a = a2, b = b2,  #                                        thetam1 = 0,  Im1 = info[2],   #                                        gm1 = h1(r = 18, theta = 1,  I = info[1],  a = a1, b = b1))) #  # b3 <- gs_spending_bound(k = 2, efficacy = TRUE, theta = 0, #                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),  #                         hgm1 = hupdate(r = 18, theta = 0,  I = info[2],  a = a2, b = b2,  #                                        thetam1 = 0,  Im1 = info[2],   #                                        gm1 = h1(r = 18, theta = 0,  I = info[1],  a = a1, b = b1))) # cat(\"The upper boundary at the 2nd analysis is (\", a3, \", \", b3, \").\\n\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_spending_bound.html","id":"inner-logic-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_spending_bound()","title":"Usage of gs_spending_bound","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"introduction-of-tevents","dir":"Articles","previous_headings":"","what":"Introduction of tEvents","title":"Usage of eEvents_df","text":"tEvents() predicts time targeted even made. designed twins AHR(): matches input/output format AHR().","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"example-1","dir":"Articles","previous_headings":"Use Cases","what":"Example 1:","title":"Usage of eEvents_df","text":"","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x <- tEvents(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, targetEvents = 200)  x %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"example-2","dir":"Articles","previous_headings":"Use Cases","what":"Example 2:","title":"Usage of eEvents_df","text":"example, verify tEvents() AHR().","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x <- AHR(enrollRates = enrollRates, failRates = failRates,           ratio = ratio, totalDuration = 20) cat(\"The number of events by 20 months is \", x$Events, \".\\n\") ## The number of events by 20 months is  208.3641 . y <- tEvents(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, targetEvents = x$Events)  cat(\"The time to get \", x$Events, \" is \", y$Time, \"months.\\n\") ## The time to get  208.3641  is  20 months."},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"inner-logic-of-tevents","dir":"Articles","previous_headings":"","what":"Inner Logic of tEvents()","title":"Usage of eEvents_df","text":"inner logic tEvents() uniroot AHR() totalDuration. Step 1: find difference AHR() different values totalDuration. Step 2: uniroot AHR() totalDuration.","code":"foo <- function(x){   ans <- AHR(enrollRates = enrollRates, failRates = failRates,               totalDuration = x, ratio = ratio)$Events - targetEvents   return(ans) } enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 targetEvents <- 200  cat(\"The difference between `targetEvents = 200` and the events after 30 months is \", foo(30), \".\\n\") ## The difference between `targetEvents = 200` and the events after 30 months is  92.45484 . res <- uniroot(foo, interval = c(0.01, 100))  ans <- AHR(enrollRates = enrollRates, failRates = failRates,             totalDuration = res$root, ratio = ratio) cat(\"After \", ans$Time, \" months, there will be \", targetEvents, \" events .\\n\") ## After  19.16437  months, there will be  200  events ."},{"path":"https://littlebeannie.github.io/gsDesign2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author, maintainer. Yujie Zhao. Author. Merck Sharp & Dohme Corp. Copyright holder.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K, Zhao Y (2022). gsDesign2: Group sequential design non-constant effect. https://github.com/LittleBeannie/gsDesign2, https://littlebeannie.github.io/gsDesign2/.","code":"@Manual{,   title = {gsDesign2: Group sequential design with non-constant effect},   author = {Keaven Anderson and Yujie Zhao},   year = {2022},   note = {https://github.com/LittleBeannie/gsDesign2, https://littlebeannie.github.io/gsDesign2/}, }"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/index.html","id":"objective","dir":"","previous_headings":"","what":"Objective","title":"Group sequential design with non-constant effect","text":"goal gsDesign2 enable fixed group sequential design non-proportional hazards. Piecewise constant enrollment, failure rates dropout rates stratified population available enable highly flexible enrollment, time--event time--dropout assumptions. Substantial flexibility top gsDesign package intended selecting boundaries. work progress, substantial capabilities enabled. Comments usability features encouraged development version package. goal gsDesign2 enable group sequential trial design time--event endpoints non-proportional hazards assumptions. package still maturing; package functions become stable, likely included gsDesign2 package.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Group sequential design with non-constant effect","text":"can install gsDesign2 :","code":"remotes::install_github(\"LittleBeannie/gsDesign2\")"},{"path":"https://littlebeannie.github.io/gsDesign2/index.html","id":"use-cases","dir":"","previous_headings":"","what":"Use cases","title":"Group sequential design with non-constant effect","text":"…","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":null,"dir":"Reference","previous_headings":"","what":"Average hazard ratio under non-proportional hazards (test version) — AHR","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"AHR() provides geometric average hazard ratio various non-proportional hazards assumptions either single multiple strata studies. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"","code":"AHR(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   totalDuration = 30,   ratio = 1,   simple = TRUE )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"enrollRates Piecewise constant enrollment rates stratum time period. failRates Piecewise constant control group failure rates, duration piecewise constant period, hazard ratio experimental vs control, dropout rates stratum time period. totalDuration Total follow-start enrollment data cutoff; can single value vector positive numbers. ratio ratio experimental control randomization. simple logical; TRUE (default), value input totalDuration overall event count, statistical information average hazard ratio given; FALSE, hazard ratio, expected events statistical information produced stratum underlying hazard ratio.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"tibble Time (totalDuration), AHR (average hazard ratio), Events (expected number events), info (information given scenarios), info0 (information related null hypothesis) value totalDuration input; simple=FALSE, Stratum t (beginning constant HR period) also returned HR returned instead AHR","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"","code":"# Example: default AHR() #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    30 0.695   58.5  14.3  14.6  # Example: default with multiple analysis times (varying totalDuration)  AHR(totalDuration = c(15, 30)) #> # A tibble: 2 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 0.786   30.3  7.44  7.57 #> 2    30 0.695   58.5 14.3  14.6   # Stratified population enrollRates <- tibble::tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),                               duration = c(2, 10, 4, 4, 8),                               rate = c(5, 10, 0, 3, 6)) failRates <- tibble::tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),                             duration = 1,                             failRate = c(.1, .2, .3, .4),                             hr = c(.9, .75, .8, .6),                             dropoutRate = .001) AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) #> # A tibble: 2 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 0.733   113.  28.1  28.3 #> 2    30 0.718   166.  41.3  41.5  # Same example, give results by strata and time period AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30), simple = FALSE) #> # A tibble: 8 × 7 #> # Groups:   Time, Stratum [4] #>    Time Stratum     t    HR Events  info info0 #>   <dbl> <chr>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 High        0  0.8   12.1   2.99  3.02 #> 2    15 High        1  0.6   23.1   5.72  5.78 #> 3    15 Low         0  0.9    9.96  2.48  2.49 #> 4    15 Low         1  0.75  68.1  16.9  17.0  #> 5    30 High        0  0.8   14.2   3.51  3.54 #> 6    30 High        1  0.6   45.2  11.2  11.3  #> 7    30 Low         0  0.9    9.96  2.48  2.49 #> 8    30 Low         1  0.75  96.8  24.1  24.2"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected events observed under piecewise exponential model — eEvents_df","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"eEvents_df computes expected events time strata assumption piecewise constant enrollment rates piecewise exponential failure censoring rates. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rates changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. intent enable sample size calculations non-proportional hazards assumptions stratified populations.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"","code":"eEvents_df(   enrollRates = tibble::tibble(duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble::tibble(duration = c(3, 100), failRate = log(2)/c(9, 18),     dropoutRate = rep(0.001, 2)),   totalDuration = 25,   simple = TRUE )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"enrollRates Enrollment rates; see details examples failRates Failure rates dropout rates period totalDuration Total follow-start enrollment data cutoff simple default (TRUE), return numeric expected number events, otherwise tibble described .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"default simple=TRUE return total expected number events real number. Otherwise, simple=FALSE tibble returned following variables period specified 'failRates': t start period, failRate failure rate period Events expected events period, records returned tibble correspond input tibble  failRates.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"periods generally supplied output input. intent enable expected event calculations tidy format maximize flexibility variety purposes.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"","code":"library(tibble) # Default arguments, simple output (total event count only) eEvents_df() #> [1] 57.3537  # Event count by time period eEvents_df(simple = FALSE) #> # A tibble: 2 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0   0.0770   22.2 #> 2     3   0.0385   35.1  # Early cutoff eEvents_df(totalDuration = .5) #> [1] 0.02850923  # Single time period example eEvents_df(enrollRates = tibble(duration = 10,rate = 10),            failRates = tibble(duration=100, failRate = log(2) / 6 ,dropoutRate = .01),            totalDuration = 22,            simple = FALSE) #> # A tibble: 1 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0    0.116   80.4  # Single time period example, multiple enrollment periods eEvents_df(enrollRates = tibble(duration = c(5,5), rate = c(10, 20)),            failRates = tibble(duration = 100, failRate = log(2)/6, dropoutRate = .01),            totalDuration = 22, simple = FALSE) #> # A tibble: 1 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0    0.116   119."},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gsDesign2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"gsDesign2: Group sequential design with non-constant effect — gsDesign2-package","title":"gsDesign2: Group sequential design with non-constant effect — gsDesign2-package","text":"Basic group sequential design computations extended.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gsDesign2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"gsDesign2: Group sequential design with non-constant effect — gsDesign2-package","text":"Maintainer: Keaven Anderson keaven_anderson@merck.com Authors: Yujie Zhao yujie.zhao@merck.com contributors: Merck Sharp & Dohme Corp [copyright holder]","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":null,"dir":"Reference","previous_headings":"","what":"gs_b: Default boundary generation — gs_b","title":"gs_b: Default boundary generation — gs_b","text":"gs_b() simplest version function used upper lower arguments gs_prob(), gs_power_nph gs_design_nph(); simply returns vector input input vector Z , k specified par[k]j returned. Note bounds need change changing information analyses, gs_b() used. instance, spending function bounds use","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gs_b: Default boundary generation — gs_b","text":"","code":"gs_b(par = NULL, k = NULL, ...)"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gs_b: Default boundary generation — gs_b","text":"par gs_b(), just Z-values boundaries; can include infinite values k NULL (default), return par, else return par[k] ... arguments passed methods info Information analyses; used function; present standard parameter boundary computation routines","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gs_b: Default boundary generation — gs_b","text":"returns vector input par k NULL, otherwise, par[k]","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"gs_b: Default boundary generation — gs_b","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gs_b: Default boundary generation — gs_b","text":"","code":"# Simple: enter a vector of length 3 for bound gs_b(par = 4:2) #> [1] 4 3 2  # 2nd element of par gs_b(par = 4:2, k = 2) #> [1] 3  # Generate an efficacy bound using a spending function # Use Lan-DeMets spending approximation of O'Brien-Fleming bound # as 50%, 75% and 100% of final spending # Information fraction IF <- c(.5, .75, 1) gs_b(par = gsDesign::gsDesign(alpha = .025, k = length(IF),       test.type = 1, sfu = gsDesign::sfLDOF,       timing = IF)$upper$bound) #> [1] 2.962588 2.359018 2.014084"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design computation with non-constant effect and information — gs_design_npe","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"gs_design_npe() derives group sequential design size, bounds boundary crossing probabilities based proportionate information effect size analyses. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires treatment effect proportionate statistical information analysis well method deriving bounds, spending. routine enables two things available gsDesign package: 1) non-constant effect, 2) flexibility boundary selection. many applications, non-proportional-hazards design function gs_design_nph() used; calls function. Initial bound types supported 1) spending bounds, 2) fixed bounds, 3) Haybittle-Peto-like bounds. requirement boundary update method can bound without knowledge future bounds. example, bounds based conditional power require knowledge future bounds supported routine; limited conditional power method demonstrated. Boundary family designs Wang-Tsiatis designs including original (non-spending-function-based) O'Brien-Fleming Pocock designs supported gs_power_npe().","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"","code":"gs_design_npe(   theta = 0.1,   theta1 = NULL,   info = 1,   info0 = NULL,   info1 = NULL,   info_scale = c(0, 1, 2),   alpha = 0.025,   beta = 0.1,   upper = gs_b,   upar = list(par = qnorm(0.975)),   lower = gs_b,   lpar = list(par = -Inf),   test_upper = TRUE,   test_lower = TRUE,   binding = FALSE,   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"theta natural parameter group sequential design representing expected incremental drift analyses; used power calculation theta1 natural parameter used lower bound spending; NULL, set theta yields usual beta-spending. set 0, spending 2-sided null hypothesis. info proportionate statistical information analyses input theta info0 proportionate statistical information null hypothesis, different alternative; impacts null hypothesis bound calculation info1 proportionate statistical information alternate hypothesis; impacts null hypothesis bound calculation alpha One-sided Type error beta Type II error upper function compute upper bound upar parameter pass function provided upper lower function compare lower bound lpar Parameter passed function provided lower test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default) indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound binding indicator whether futility bound binding; default FALSE recommended r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"tibble columns Analysis, Bound, Z, Probability,  theta, info, info0","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"inputs info info0 vectors length increasing positive numbers. design returned change constant scale factor ensure design power 1 - beta. bound specifications upper, lower, upar, lpar used ensure Type error boundary properties specified.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"Keaven Anderson keaven\\_anderson@merck.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"","code":"library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union library(gsDesign) #> Loading required package: ggplot2  # ---------------------------------#  #         example 1                # # ---------------------------------#  # Single analysis # Lachin book p 71 difference of proportions example pc <- .28            # Control response rate pe <- .40            # Experimental response rate p0 <- (pc + pe) / 2  # Ave response rate under H0  # Information per increment of 1 in sample size info0 <- 1 / (p0 * (1 - p0) * 4) info <- 1 / (pc * (1 - pc) * 2 + pe * (1 - pe) * 2)  # Result should round up to next even number = 652 # Divide information needed under H1 by information per patient added gs_design_npe(theta = pe - pc, info = info, info0 = info0) #> # A tibble: 1 × 10 #>   Analysis Bound     Z Probability Probability0 theta  info info0 info1    IF #>      <dbl> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  1.96         0.9        0.025  0.12  737.  725.  737.     1   # ---------------------------------#  #         example 2                # # ---------------------------------#  # Fixed bound x <- gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 80,   info0 = (1:3) * 80,   upper = gs_b,   upar = list(par = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound),   lower = gs_b,   lpar = list(par = c(-1, 0, 0))) x #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.00120     0.000104   0.1 0.333  45.6  45.6  45.6 #> 2        1 Lower -1        0.0470      0.159      0.1 0.333  45.6  45.6  45.6 #> 3        2 Upper  2.51     0.273       0.00605    0.2 0.667  91.1  91.1  91.1 #> 4        2 Lower  0        0.0619      0.513      0.2 0.667  91.1  91.1  91.1 #> 5        3 Upper  1.99     0.900       0.0249     0.3 1     137.  137.  137.  #> 6        3 Lower  0        0.0619      0.606      0.3 1     137.  137.  137.   # Same upper bound; this represents non-binding Type I error and will total 0.025 gs_power_npe(   theta = rep(0, 3),   info = (x %>% filter(Bound == \"Upper\"))$info,   upper = gs_b,   upar = list(par = (x %>% filter(Bound == \"Upper\"))$Z),   lower = gs_b,   lpar = list(par = rep(-Inf, 3))) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71    0.000104     0      0 0.333  45.6  45.6  45.6 #> 2        2 Upper  2.51    0.00605      0      0 0.667  91.1  91.1  91.1 #> 3        3 Upper  1.99    0.0250       0      0 1     137.  137.  137.   # ---------------------------------#  #         example 3                # # ---------------------------------#  # Spending bound examples # Design with futility only at analysis 1; efficacy only at analyses 2, 3 # Spending bound for efficacy; fixed bound for futility # NOTE: test_upper and test_lower DO NOT WORK with gs_b; must explicitly make bounds infinite # test_upper and test_lower DO WORK with gs_spending_bound gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   info0 = (1:3) * 40,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_b,   lpar = list(par = c(-1, -Inf, -Inf)),   test_upper = c(FALSE, TRUE, TRUE)) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Lower -1         0.0477      0.159     0.1 0.333  44.6  44.6  44.6 #> 2        2 Upper  2.51      0.267       0.00605   0.2 0.667  89.1  89.1  89.1 #> 3        3 Upper  1.99      0.900       0.0249    0.3 1     134.  134.  134.  # one can try `info_scale = 1` or `info_scale = 0` here gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   info0 = (1:3) * 30,   info_scale = 1,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_b,   lpar = list(par = c(-1, -Inf, -Inf)),   test_upper = c(FALSE, TRUE, TRUE)) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Lower -1         0.0477      0.159     0.1 0.333  44.6  44.6  44.6 #> 2        2 Upper  2.51      0.267       0.00605   0.2 0.667  89.1  89.1  89.1 #> 3        3 Upper  1.99      0.900       0.0249    0.3 1     134.  134.  134.   # ---------------------------------#  #         example 4                # # ---------------------------------#  # Spending function bounds # 2-sided asymmetric bounds # Lower spending based on non-zero effect gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   info0 = (1:3) * 30,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),               info = (1:3) * 30),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) #> Error in uniroot(errbeta, lower = min_x, upper = max_x, theta = theta,  :  #>   object 'max_x' not found #> Error in gs_design_npe(theta = c(0.1, 0.2, 0.3), info = (1:3) * 40, info0 = (1:3) *     30, upper = gs_spending_bound, upar = list(par = list(sf = gsDesign::sfLDOF,     total_spend = 0.025, param = NULL, timing = NULL), info = (1:3) *     30), lower = gs_spending_bound, lpar = list(par = list(sf = gsDesign::sfHSD,     total_spend = 0.1, param = -1, timing = NULL))): gs_design_npe(): Sample size solution not found!  # ---------------------------------#  #         example 5                # # ---------------------------------#  # Two-sided symmetric spend, O'Brien-Fleming spending # Typically, 2-sided bounds are binding xx <- gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))) xx #> # A tibble: 6 × 10 #>   Analysis Bound      Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr>  <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.00104      0.000104   0.1 0.333  39.8  39.8  39.8 #> 2        1 Lower -3.08     0.000104     0.00104    0.1 0.333  39.8  39.8  39.8 #> 3        2 Upper  2.51     0.233        0.00605    0.2 0.667  79.5  79.5  79.5 #> 4        2 Lower -0.728    0.00605      0.233      0.2 0.667  79.5  79.5  79.5 #> 5        3 Upper  1.99     0.900        0.0250     0.3 1     119.  119.  119.  #> 6        3 Lower  1.28     0.0250       0.900      0.3 1     119.  119.  119.   # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upper = gs_b,   lower = gs_b,   upar = list(par = (xx %>% filter(Bound == \"Upper\"))$Z),   lpar = list(par = -(xx %>% filter(Bound == \"Upper\"))$Z)) #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71  0.00104      0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51  0.235        0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99  0.902        0.3    0.3 1       120   120   120 #> 4        1 Lower -3.71  0.00000704   0.1    0.1 0.333    40    40    40 #> 5        2 Lower -2.51  0.0000151    0.2    0.2 0.667    80    80    80 #> 6        3 Lower -1.99  0.0000151    0.3    0.3 1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":null,"dir":"Reference","previous_headings":"","what":"Information and effect size based on AHR approximation — gs_info_ahr","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"Based piecewise enrollment rate, failure rate, dropout rates computes approximate information effect size using average hazard ratio model.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"","code":"gs_info_ahr(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   ratio = 1,   events = NULL,   analysisTimes = NULL )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"enrollRates enrollment rates failRates failure dropout rates ratio Experimental:Control randomization ratio events Targeted minimum events analysis analysisTimes Targeted minimum study duration analysis","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"tibble columns Analysis, Time, AHR, Events, theta, info, info0. info, info0 contains statistical information H1, H0, respectively. analysis k, Time[k] maximum analysisTimes[k] expected time required accrue targeted events[k]. AHR expected average hazard ratio analysis.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"AHR() function computes statistical information targeted event times. tEvents() function used get events average HR targeted analysisTimes.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"","code":"library(gsDesign) library(gsDesign2)  # ------------------------ # #       Example 1          # # ------------------------ # # Only put in targeted events gs_info_ahr(events = c(30, 40, 50)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  14.9   30.0 0.787 0.240  7.37  7.50 #> 2        2  19.2   40.0 0.744 0.295  9.79 10.0  #> 3        3  24.5   50.0 0.713 0.339 12.2  12.5   # ------------------------ # #       Example 2          # # ------------------------ # # Only put in targeted analysis times gs_info_ahr(analysisTimes = c(18, 27, 36)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    18   37.6 0.755 0.282  9.21  9.40 #> 2        2    27   54.0 0.704 0.351 13.2  13.5  #> 3        3    36   66.2 0.683 0.381 16.3  16.6   # ------------------------ # #       Example 3          # # ------------------------ # # Some analysis times after time at which targeted events accrue # Check that both Time >= input analysisTime and Events >= input events gs_info_ahr(events = c(30, 40, 50), analysisTimes = c(16, 19, 26)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  16     33.1 0.776 0.254  8.12  8.27 #> 2        2  19.2   40.0 0.744 0.295  9.79 10.0  #> 3        3  26     52.4 0.707 0.346 12.8  13.1  gs_info_ahr(events = c(30, 40, 50), analysisTimes = c(14, 20, 24)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  14.9   30.0 0.787 0.240  7.37  7.50 #> 2        2  20     41.7 0.738 0.304 10.2  10.4  #> 3        3  24.5   50.0 0.713 0.339 12.2  12.5"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential bound computation with non-constant effect — gs_power_npe","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"gs_power_npe() derives group sequential bounds boundary crossing probabilities design. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires treatment effect statistical information analysis well method deriving bounds, spending. routine enables two things available gsDesign package: 1) non-constant effect, 2) flexibility boundary selection. many applications, non-proportional-hazards design function gs_design_nph() used; calls function. Initial bound types supported 1) spending bounds, 2) fixed bounds, 3) Haybittle-Peto-like bounds. requirement boundary update method can bound without knowledge future bounds. example, bounds based conditional power require knowledge future bounds supported routine; limited conditional power method demonstrated. Boundary family designs Wang-Tsiatis designs including original (non-spending-function-based) O'Brien-Fleming Pocock designs supported gs_power_npe().","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"","code":"gs_power_npe(   theta = 0.1,   theta1 = NULL,   info = 1,   info0 = NULL,   info1 = NULL,   info_scale = c(0, 1, 2),   binding = FALSE,   upper = gs_b,   upar = list(par = qnorm(0.975)),   lower = gs_b,   lpar = list(par = -Inf),   test_upper = TRUE,   test_lower = TRUE,   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"theta natural parameter group sequential design representing expected incremental drift analyses; used power calculation theta1 natural parameter alternate hypothesis, needed lower bound computation info statistical information analyses input theta info0 statistical information null hypothesis, different info; impacts null hypothesis bound calculation info1 statistical information hypothesis used futility bound calculation different info; impacts futility hypothesis bound calculation info_scale used gs_spending_bound used binding indicator whether futility bound binding; default FALSE recommended upper function compute upper bound upar parameter pass upper lower function compare lower bound lpar parameter pass lower test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default)  indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"Keaven Anderson keaven_anderson@merck.com","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"","code":"library(gsDesign) library(dplyr)  # Default (single analysis; Type I error controlled) gs_power_npe(theta = 0) %>%    filter(Bound == \"Upper\") #> # A tibble: 1 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  1.96      0.0250     0      0     1     1     1     1  # Fixed bound gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,    upper = gs_b,    upar = list(par = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound),   lower = gs_b,    lpar = list(par = c(-1, 0, 0))) #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.00104   0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51     0.235     0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99     0.869     0.3    0.3 1       120   120   120 #> 4        1 Lower -1        0.0513    0.1    0.1 0.333    40    40    40 #> 5        2 Lower  0        0.0715    0.2    0.2 0.667    80    80    80 #> 6        3 Lower  0        0.0715    0.3    0.3 1       120   120   120  # Same fixed efficacy bounds, no futility bound (i.e., non-binding bound), null hypothesis gs_power_npe(   theta = rep(0, 3),    info = (1:3) * 40,   upar = list(par = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound),   lpar = list(par = rep(-Inf, 3))) %>%    filter(Bound == \"Upper\") #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71    0.000104     0      0 0.333    40    40    40 #> 2        2 Upper  2.51    0.00605      0      0 0.667    80    80    80 #> 3        3 Upper  1.99    0.0250       0      0 1       120   120   120  # Fixed bound with futility only at analysis 1; efficacy only at analyses 2, 3 gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,   upper = gs_b,   upar = list(par = c(Inf, 3, 2)),    lower = gs_b,   lpar = list(par = c(qnorm(.1), -Inf, -Inf))) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        2 Upper  3         0.113    0.2    0.2 0.667    80    80    80 #> 2        3 Upper  2         0.887    0.3    0.3 1       120   120   120 #> 3        1 Lower -1.28      0.0278   0.1    0.1 0.333    40    40    40  # Spending function bounds # Lower spending based on non-zero effect gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) #> # A tibble: 6 × 10 #>   Analysis Bound       Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr>   <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71       0.00104   0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51       0.235     0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99       0.883     0.3    0.3 1       120   120   120 #> 4        1 Lower -1.36       0.0230    0.1    0.1 0.333    40    40    40 #> 5        2 Lower  0.0726     0.0552    0.2    0.2 0.667    80    80    80 #> 6        3 Lower  1.86       0.100     0.3    0.3 1       120   120   120  # Same bounds, but power under different theta gs_power_npe(   theta = c(.15, .25, .35),    info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL))) #> # A tibble: 6 × 10 #>   Analysis Bound      Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr>  <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71      0.00288  0.15   0.15 0.333    40    40    40 #> 2        2 Upper  2.51      0.391    0.25   0.25 0.667    80    80    80 #> 3        3 Upper  1.99      0.931    0.35   0.35 1       120   120   120 #> 4        1 Lower -1.05      0.0230   0.15   0.15 0.333    40    40    40 #> 5        2 Lower  0.520     0.0552   0.25   0.25 0.667    80    80    80 #> 6        3 Lower  2.41      0.100    0.35   0.35 1       120   120   120  # Two-sided symmetric spend, O'Brien-Fleming spending # Typically, 2-sided bounds are binding x <- gs_power_npe(   theta = rep(0, 3),    info = (1:3) * 40,   binding = TRUE,   upper = gs_spending_bound,   upar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)),   lower = gs_spending_bound,   lpar = list(par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)))  # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,   binding = TRUE,   upar = list(par = (x %>% filter(Bound == \"Upper\"))$Z),   lpar = list(par = -(x %>% filter(Bound == \"Upper\"))$Z)) #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71  0.00104      0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51  0.235        0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99  0.902        0.3    0.3 1       120   120   120 #> 4        1 Lower -3.71  0.00000704   0.1    0.1 0.333    40    40    40 #> 5        2 Lower -2.51  0.0000151    0.2    0.2 0.667    80    80    80 #> 6        3 Lower -1.99  0.0000151    0.3    0.3 1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive spending bound for group sequential boundary — gs_spending_bound","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"Computes one bound time based spending given distributional assumptions. user specifies gs_spending_bound() use functions, intended use . important user specifications made list provided functions using gs_spending_bound(). Function uses numerical integration Newton-Raphson iteration derive individual bound group sequential design satisfies targeted boundary crossing probability. Algorithm simple extension Chapter 19 Jennison Turnbull (2000).","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"","code":"gs_spending_bound(   k = 1,   par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL,     max_info = NULL),   hgm1 = NULL,   theta = 0.1,   info = 1:3,   efficacy = TRUE,   test_bound = TRUE,   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"k analysis bound computed par list following items: sf (class spending function), total_spend (total spend), param (parameters needed spending function sf()), timing (vector containing values spending function evaluated NULL information-based spending used), max_info (timing NULL, can input positive number used info information fraction analysis) hgm1 subdensity grid h1 (k=2) hupdate (k>2) analysis k-1; k=1, used may NULL theta natural parameter used lower bound spending; represents average drift time analysis least analysis k; upper bound spending always set null hypothesis (theta = 0) info statistical information analyses, least analysis k efficacy TRUE (default) efficacy bound, FALSE otherwise test_bound logical vector length info indicate analyses bound r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"returns numeric bound (possibly infinite) , upon failure, generates error message.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"Jennison C Turnbull BW (2000), Group Sequential Methods Applications Clinical Trials. Boca Raton: Chapman Hall.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"Keaven Anderson keaven_anderson@merck.com","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict time at which a targeted event count is achieved — tEvents","title":"Predict time at which a targeted event count is achieved — tEvents","text":"tEvents() made match input format AHR() solve time expected accumulated events equal input target. Enrollment failure rate distributions specified follows. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict time at which a targeted event count is achieved — tEvents","text":"","code":"tEvents(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9) * 5),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   targetEvents = 150,   ratio = 1,   interval = c(0.01, 100) )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict time at which a targeted event count is achieved — tEvents","text":"enrollRates Piecewise constant enrollment rates stratum time period. failRates Piecewise constant control group failure rates, duration piecewise constant period, hazard ratio experimental vs control, dropout rates stratum time period. targetEvents targeted number events achieved. ratio Experimental:Control randomization ratio. interval interval presumed include time expected event count equal targetEvents.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict time at which a targeted event count is achieved — tEvents","text":"tibble Time (computed match events targetEvents), AHR (average hazard ratio), Events (targetEvents input), info (information given scenarios), info0 (information related null hypothesis) value totalDuration input;","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict time at which a targeted event count is achieved — tEvents","text":"","code":"# ------------------------#  #      Example 1          # # ------------------------# # default tEvents() #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1  14.9 0.787   150.  36.9  37.5  # ------------------------#  #      Example 2          # # ------------------------# # check that result matches a finding using AHR() # Start by deriving an expected event count enrollRates <- tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18),                              hr = c(.9,.6), dropoutRate = rep(.001, 2)) totalDuration <- 20 xx <- AHR(enrollRates, failRates, totalDuration) xx #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    20 0.738   208.  51.0  52.1  # Next we check that the function confirms the timing of the final analysis. tEvents(enrollRates, failRates,          targetEvents = xx$Events, interval = c(.5, 1.5) * xx$Time) #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1  20.0 0.738   208.  51.0  52.1"}]
