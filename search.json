[{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_AHR.html","id":"test-1-unstratified-population","dir":"Articles","previous_headings":"","what":"Test 1: unstratified population","title":"Test of the function AHR","text":"","code":"enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001) x1 <- AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) x2 <- AHR_(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30))  expect_equal(x1, x2)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_AHR.html","id":"test-2-stratified-population","dir":"Articles","previous_headings":"","what":"Test 2: stratified population","title":"Test of the function AHR","text":"","code":"enrollRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001)  x1 <- AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) x2 <- AHR_(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30))  expect_equal(x1, x2)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_eEvents_df.html","id":"test-1","dir":"Articles","previous_headings":"","what":"Test 1","title":"Test of the function eEvents_df","text":"","code":"enrollRates <- tibble(duration = c(2, 1, 2), rate = c(5, 10, 20)) failRates <- tibble(duration = c(1, 1, 1),failRate = c(.05, .02, .01), dropoutRate = .01) totalDuration <- 20  x1 <- gsDesign::eEvents(lambda = failRates$failRate,                         S = failRates$duration[1 : (nrow(failRates) - 1)],                         eta = failRates$dropoutRate,                         gamma = enrollRates$rate,                         R = enrollRates$duration,                         T = totalDuration)$d  x2 <- eEvents_df_(enrollRates, failRates, totalDuration, simple = TRUE)  x3 <- eEvents_df(enrollRates, failRates, totalDuration, simple = TRUE)  tibble(method = c(\"gsDesign\", \"old version\", \"new version\"),        exp_events = c(x1, x2, x3)) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_eEvents_df.html","id":"test-2","dir":"Articles","previous_headings":"","what":"Test 2","title":"Test of the function eEvents_df","text":"","code":"enrollRates <- tibble(duration = c(1, 1, 8), rate = c(3, 2, 0)) failRates <- tibble(duration = c(4, Inf), failRate = c(.03, .06), dropoutRate = c(.001, .002)) totalDuration <- 7  x <- eEvents_df(enrollRates, failRates, totalDuration, simple = FALSE) %>% data.frame() # expected checked with alternate calculations in gsSurvNPH vignette y <- data.frame(t = c(0, 4), failRate = c(0.03, 0.06), Events = c(0.5642911, 0.5194821))  x %>% gt() %>% tab_header(title = \"From gsDesign2 new version\") y %>% gt() %>% tab_header(title = \"From gsSurvNPH vignette\")"},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gridpts_h1_hupdate.html","id":"default-n01","dir":"Articles","previous_headings":"Tests of gridpts","what":"default (N(0,1))","title":"Test of the functions gridpts, h1, hupdate","text":"approximate variance standard normal (.e., 1)","code":"x1 <- gridpts_(mu = 0, a = -Inf, b = Inf, r = 18) x2 <- gridpts(mu = 0, a = -Inf, b = Inf, r = 18) x3a <- gsDesign::normalGrid(bounds = c(-10, 10), mu = 0, sigma = 1, r = 18) x3b <- gsDesign::normalGrid(bounds = c(-20, 20), mu = 0, sigma = 1, r = 18) x3c <- gsDesign::normalGrid(bounds = c(-80, 80), mu = 0, sigma = 1, r = 18) tibble(z_x1 = x1$z,        z_x2 = x2$z,        z_x3b = x3b$z,        z_diff = x2$z - x3b$z) ## # A tibble: 213 × 4 ##      z_x1   z_x2  z_x3b z_diff ##     <dbl>  <dbl>  <dbl>  <dbl> ##  1 -14.6  -14.6  -14.6       0 ##  2 -13.2  -13.2  -13.2       0 ##  3 -11.8  -11.8  -11.8       0 ##  4 -11.0  -11.0  -11.0       0 ##  5 -10.2  -10.2  -10.2       0 ##  6  -9.59  -9.59  -9.59      0 ##  7  -9.02  -9.02  -9.02      0 ##  8  -8.57  -8.57  -8.57      0 ##  9  -8.12  -8.12  -8.12      0 ## 10  -7.76  -7.76  -7.76      0 ## # … with 203 more rows ## # ℹ Use `print(n = ...)` to see more rows"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gridpts_h1_hupdate.html","id":"approximate-probability-of-n01-above--95-quantile-i-e---05","dir":"Articles","previous_headings":"Tests of gridpts","what":"approximate probability of N(0,1) above .95 quantile (i.e., .05)","title":"Test of the functions gridpts, h1, hupdate","text":"","code":"x1 <- gridpts_(mu = 0, a = qnorm(0.95), b = Inf, r = 18) x2 <- gridpts(mu = 0, a = qnorm(0.95), b = Inf, r = 18) x3a <- gsDesign::normalGrid(bounds = c(qnorm(0.95), 10), mu = 0, sigma = 1, r = 18) x3b <- gsDesign::normalGrid(bounds = c(qnorm(0.95), 20), mu = 0, sigma = 1, r = 18) x3c <- gsDesign::normalGrid(bounds = c(qnorm(0.95), 80), mu = 0, sigma = 1, r = 18)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gridpts_h1_hupdate.html","id":"approximate-probability-of-n0-5-1-above--95-quantile-i-e---05","dir":"Articles","previous_headings":"Tests of gridpts","what":"approximate probability of N(0.5, 1) above .95 quantile (i.e., .05)","title":"Test of the functions gridpts, h1, hupdate","text":"","code":"x1 <- gridpts_(mu = 0.5, a = qnorm(0.95), b = Inf, r = 18) x2 <- gridpts(mu = 0.5, a = qnorm(0.95), b = Inf, r = 18) x3a <- gsDesign::normalGrid(bounds = c(qnorm(0.95), 10), mu = 0.5, sigma = 1, r = 18) x3b <- gsDesign::normalGrid(bounds = c(qnorm(0.95), 20), mu = 0.5, sigma = 1, r = 18) x3c <- gsDesign::normalGrid(bounds = c(qnorm(0.95), 80), mu = 0.5, sigma = 1, r = 18)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-1","dir":"Articles","previous_headings":"","what":"Test 1","title":"Test of the function gs_design_ahr","text":"Call defaults.","code":"x1 <- gs_design_ahr() x2 <- gs_design_ahr_()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-2","dir":"Articles","previous_headings":"","what":"Test 2","title":"Test of the function gs_design_ahr","text":"Single analysis.","code":"x1 <- gs_design_ahr(analysisTimes = 40) x2 <- gs_design_ahr_(analysisTimes = 40)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-3","dir":"Articles","previous_headings":"","what":"Test 3","title":"Test of the function gs_design_ahr","text":"Multiple analysisTimes.","code":"x1 <- gs_design_ahr(analysisTimes = c(12, 24, 36)) x2 <- gs_design_ahr_(analysisTimes = c(12, 24, 36))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-4","dir":"Articles","previous_headings":"","what":"Test 4","title":"Test of the function gs_design_ahr","text":"Specified information fraction","code":"x1 <- gs_design_ahr(IF = c(.25, .75, 1), analysisTimes = 36) x2 <- gs_design_ahr_(IF = c(.25, .75, 1), analysisTimes = 36)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-5","dir":"Articles","previous_headings":"","what":"Test 5","title":"Test of the function gs_design_ahr","text":"Multiple analysis times & driven times.","code":"x1 <- gs_design_ahr(IF = c(.25, .75, 1), analysisTimes = c(12, 25, 36)) x2 <- gs_design_ahr_(IF = c(.25, .75, 1), analysisTimes = c(12, 25, 36))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-6","dir":"Articles","previous_headings":"","what":"Test 6","title":"Test of the function gs_design_ahr","text":"Multiple analysis times & driven .","code":"x1 <- gs_design_ahr(IF = c(1/3, .8, 1), analysisTimes = c(12, 25, 36)) x2 <- gs_design_ahr_(IF = c(1/3, .8, 1), analysisTimes = c(12, 25, 36))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-7","dir":"Articles","previous_headings":"","what":"Test 7","title":"Test of the function gs_design_ahr","text":"2-sided symmetric design O’Brien-Fleming spending","code":"x1 <- gs_design_ahr(analysisTimes = c(12, 24, 36), binding = TRUE,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     h1_spending = FALSE) x2 <- gs_design_ahr_(analysisTimes = c(12, 24, 36), binding = TRUE,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     h1_spending = FALSE)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_ahr.html","id":"test-8","dir":"Articles","previous_headings":"","what":"Test 8","title":"Test of the function gs_design_ahr","text":"Pocock lower spending H1 (NPH).","code":"x1 <- gs_design_ahr(analysisTimes = c(12, 24, 36), binding = TRUE,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfLDPocock, total_spend = 0.1, param = NULL, timing = NULL),                     h1_spending = TRUE)  x2 <- gs_design_ahr_(analysisTimes = c(12, 24, 36), binding = TRUE,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfLDPocock, total_spend = 0.1, param = NULL, timing = NULL),                     h1_spending = TRUE)"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"new-version","dir":"Articles","previous_headings":"Test 1: verify by gs_power_npe","what":"new version","title":"Test of the function gs_design_npe","text":"power 0.9. re-use bounds alternate hypothesis, can get power close 0.9.","code":"x <- gs_design_npe(theta = c(.1, .2, .3), info = (1:3) * 40, beta = 0.1,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL), binding = TRUE) x %>% gt() gs_power_npe(theta = c(.1, .2, .3),info = (1:3) * 40,              upper = gs_b, upar = (x %>% filter(Bound == \"Upper\"))$Z,              lower = gs_b, lpar = -(x %>% filter(Bound == \"Upper\"))$Z,              binding = TRUE # Always use binding = TRUE for power calculations              ) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"old-version","dir":"Articles","previous_headings":"Test 1: verify by gs_power_npe","what":"old version","title":"Test of the function gs_design_npe","text":"power 0.9. re-use bounds alternate hypothesis, can get power close 0.9.","code":"x <- gs_design_npe_(theta = c(.1, .2, .3), info = (1:3) * 40, beta = 0.1,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL), binding = TRUE) x %>% gt() gs_power_npe_(theta = c(.1, .2, .3),info = (1:3) * 40,              upper = gs_b, upar = (x %>% filter(Bound == \"Upper\"))$Z,              lower = gs_b, lpar = -(x %>% filter(Bound == \"Upper\"))$Z,              binding = TRUE # Always use binding = TRUE for power calculations              ) %>% gt()"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"difference-of-proportions","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"difference of proportions","title":"Test of the function gs_design_npe","text":"","code":"# Lachin book p71  pc <- .28            # Control response rate pe <- .40            # Experimental response rate p0 <- (pc + pe) / 2  # Ave response rate under H0  # Information per increment of 1 in sample size info0 <- 1 / (p0 * (1 - p0) * 4) info <- 1 / (pc * (1 - pc) * 2 + pe * (1 - pe) * 2)  # Result should round up to next even number = 652 # Divide information needed under H1 by information per patient added x1_a <- gs_design_npe(theta = pe - pc, info = info, info0 = info0, info_scale = 0) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_design_npe(theta = pe - pc, info = info, info0 = info0, info_scale = 1) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_design_npe(theta = pe - pc, info = info, info0 = info0, info_scale = 2) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = pe - pc, info = info, info0 = info0) %>% mutate(`Computated from` = \"old version\")"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"info-info0-info1","dir":"Articles","previous_headings":"Test 1: examples in spec > fixed design","what":"info = info0 = info1","title":"Test of the function gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info_scale = 0,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                       lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info_scale = 1,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                       lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info_scale = 2,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                       lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2) x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 80,                      upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"info-info0-info1-1","dir":"Articles","previous_headings":"Test 1: examples in spec > fixed design","what":"info != info0 != info1","title":"Test of the function gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 90 + 10, info1 = (1:3) * 70 - 5, info_scale = 0,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                       lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 90+ 10, info1 = (1:3) * 70 - 5, info_scale = 1,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                       lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 80, info0 = (1:3) * 90+ 10, info1 = (1:3) * 70 - 5, info_scale = 2,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                       lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2) x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 90+ 10, info1 = (1:3) * 70 - 5,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"futility-at-ia1-efficacy-only-at-ia2-fa","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"futility at IA1; efficacy only at IA2 +FA","title":"Test of the function gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 40, info_scale = 0,                       upper = gs_spending_bound, upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_b, lpar = c(-1, -Inf, -Inf),                       test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0)  x1_b <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 40, info_scale = 1,                       upper = gs_spending_bound, upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_b, lpar = c(-1, -Inf, -Inf),                       test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1)  x1_c <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 40, info_scale = 2,                       upper = gs_spending_bound, upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_b, lpar = c(-1, -Inf, -Inf),                       test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = c(.1, .2, .3),                     info = (1:3) * 40, info0 = (1:3) * 40,                      upper = gs_spending_bound, upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_b, lpar =  c(-1, -Inf, -Inf),                     test_upper = c(FALSE, TRUE, TRUE)) %>% mutate(`Computated from` = \"old version\", `Info scale` = 0) x1_a %>%    union_all(x1_b) %>%    union_all(x1_c) %>%    union_all(x2) %>%    arrange(Analysis) %>%    group_by(Analysis, Bound) %>%    gt() %>%    tab_style(     style = list(cell_fill(color = \"#d3edeb\")),     locations = cells_body(rows = `Computated from` == \"old version\"))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"spending-bounds","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"spending bounds","title":"Test of the function gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 40, info0 = (1:3) * 50, info_scale = 0,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0)  x1_b <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 40, info0 = (1:3) * 50, info_scale = 1,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1)  x1_c <- gs_design_npe(theta = c(.1, .2, .3),                        info = (1:3) * 40, info0 = (1:3) * 50, info_scale = 2,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 40, info0 = (1:3) * 50,                       upper = gs_spending_bound,                      upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                      lower = gs_spending_bound,                      lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_design_npe.html","id":"sided-symmetric-spend","dir":"Articles","previous_headings":"Test 1: examples in spec","what":"2-sided symmetric spend","title":"Test of the function gs_design_npe","text":"","code":"x1_a <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info_scale = 0,                       binding = TRUE,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0)  x1_b <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info_scale = 1,                       binding = TRUE,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1)  x1_c <- gs_design_npe(theta = c(.1, .2, .3),                       info = (1:3) * 40, info_scale = 2,                       binding = TRUE,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2)  x2 <- gs_design_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 40,                        binding = TRUE,                       upper = gs_spending_bound,                       upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                       lower = gs_spending_bound,                       lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_ahr.html","id":"test-1","dir":"Articles","previous_headings":"","what":"Test 1","title":"Test of the function gs_power_ahr","text":"","code":"x1 <- gs_power_ahr()  x2 <- gs_power_ahr_()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_ahr.html","id":"test-2","dir":"Articles","previous_headings":"","what":"Test 2","title":"Test of the function gs_power_ahr","text":"","code":"x1 <- gs_power_ahr(analysisTimes = c(12, 24, 36),                    events = NULL,                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))  x2 <- gs_power_ahr_(analysisTimes = c(12, 24, 36),                    events = NULL,                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_ahr.html","id":"test-3","dir":"Articles","previous_headings":"","what":"Test 3","title":"Test of the function gs_power_ahr","text":"","code":"x1 <- gs_power_ahr(analysisTimes = NULL,                    events = c(20, 50, 70),                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))  x2 <- gs_power_ahr_(analysisTimes = NULL,                    events = c(20, 50, 70),                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_ahr.html","id":"test-4","dir":"Articles","previous_headings":"","what":"Test 4","title":"Test of the function gs_power_ahr","text":"","code":"x1 <- gs_power_ahr(analysisTimes = c(12, 24, 36),                    events = c(30, 40, 50),                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))  x2 <- gs_power_ahr_(analysisTimes = c(12, 24, 36),                    events = c(30, 40, 50),                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"default","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Default","title":"Test of the function gs_power_npe","text":"default gs_power_npe single analysis type error controlled.","code":"x1 <- gs_power_npe(theta = 0) %>% filter(Bound == \"Upper\") x2 <- gsDesign2:::gs_power_npe_(theta = 0) %>% filter(Bound == \"Upper\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"fixed-bound","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Fixed bound","title":"Test of the function gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = c(.1, .2, .3),                    info = (1:3) * 40,                    upper = gs_b,                    upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,                    lower = gs_b,                    lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\")  x2 <- gs_power_npe_(theta = c(.1, .2, .3),                     info = (1:3) * 40,                     upper = gs_b,                     upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,                     lower = gs_b,                     lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"same-fixed-efficacy-bounds-no-futility-bound-i-e--non-binding-bound-null-hypothesis","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Same fixed efficacy bounds, no futility bound (i.e., non-binding bound), null hypothesis","title":"Test of the function gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = rep(0, 3),                    info = (1:3) * 40,                    upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,                    lpar = rep(-Inf, 3)) %>% mutate(`Computated from` = \"new version\")  x2 <- gs_power_npe_(theta = rep(0, 3),                     info = (1:3) * 40,                     upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,                     lpar = rep(-Inf, 3)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"fixed-bound-with-futility-only-at-analysis-1-efficacy-only-at-analyses-2-3","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Fixed bound with futility only at analysis 1; efficacy only at analyses 2, 3","title":"Test of the function gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = c(.1, .2, .3),                    info = (1:3) * 40,                    upper = gs_b,                    upar = c(Inf, 3, 2),                    lower = gs_b,                    lpar = c(qnorm(.1), -Inf, -Inf)) %>% mutate(`Computated from` = \"new version\")  x2 <- gs_power_npe_(theta = c(.1, .2, .3),                     info = (1:3) * 40,                     upper = gs_b,                     upar = c(Inf, 3, 2),                     lower = gs_b,                     lpar = c(qnorm(.1), -Inf, -Inf)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"spending-function-bounds","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Spending function bounds","title":"Test of the function gs_power_npe","text":"","code":"# Lower spending based on non-zero effect x1 <- gs_power_npe(theta = c(.1, .2, .3),                    info = (1:3) * 40,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"new version\")  x2 <- gs_power_npe_(theta = c(.1, .2, .3),                     info = (1:3) * 40,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"same-bounds-but-power-under-different-theta","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Same bounds, but power under different theta","title":"Test of the function gs_power_npe","text":"","code":"x1 <- gs_power_npe(theta = c(.15, .25, .35),                    info = (1:3) * 40,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"new version\")  x2 <- gs_power_npe_(theta = c(.15, .25, .35),                     info = (1:3) * 40,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"two-sided-symmetric-spend-obrien-fleming-spending","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Two-sided symmetric spend, O’Brien-Fleming spending","title":"Test of the function gs_power_npe","text":"Typically, 2-sided bounds binding","code":"x1 <- gs_power_npe(theta = rep(0, 3),                    info = (1:3) * 40,                    binding = TRUE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"new version\")  x2 <- gs_power_npe_(theta = rep(0, 3),                      info = (1:3) * 40,                     binding = TRUE,                     upper = gs_spending_bound,                     upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                     lower = gs_spending_bound,                     lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"re-use-these-bounds-under-alternate-hypothesis","dir":"Articles","previous_headings":"Test 1: Examples from spec","what":"Re-use these bounds under alternate hypothesis","title":"Test of the function gs_power_npe","text":"Always use binding = TRUE power calculations","code":"xx1 <- gs_power_npe(theta = c(.1, .2, .3),                      info = (1:3) * 40,                     binding = TRUE,                     upar = (x1 %>% filter(Bound == \"Upper\"))$Z,                     lpar = -(x1 %>% filter(Bound == \"Upper\"))$Z) %>% mutate(`Computated from` = \"new version\")  xx2 <- gs_power_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 40,                      binding = TRUE,                      upar = (x1 %>% filter(Bound == \"Upper\"))$Z,                      lpar = -(x1 %>% filter(Bound == \"Upper\"))$Z) %>% mutate(`Computated from` = \"old version\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"test-2-fixed-design","dir":"Articles","previous_headings":"","what":"Test 2: Fixed Design","title":"Test of the function gs_power_npe","text":"power following analysis expected 0.975.","code":"gs_power_npe(theta = 0,               upper = gs_b, upar = qnorm(0.025),              lower = gs_b, lpar = -Inf) ## # A tibble: 1 × 10 ##   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 ##      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1 Upper -1.96       0.975     0      0     1     1     1     1"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"test-3-info-info0-info1","dir":"Articles","previous_headings":"","what":"Test 3: info != info0 != info1","title":"Test of the function gs_power_npe","text":"one inputs info upar","code":"x1_a <- gs_power_npe(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 90 + 10, info1 = (1:3) * 70 - 5, info_scale = 0,                      upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 0) x1_b <- gs_power_npe(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 90 + 10, info1 = (1:3) * 70 - 5, info_scale = 1,                      upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 1) x1_c <- gs_power_npe(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 90 + 10, info1 = (1:3) * 70 - 5, info_scale = 2,                      upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"new version\", `Info scale` = 2) x2 <- gs_power_npe_(theta = c(.1, .2, .3),                       info = (1:3) * 80, info0 = (1:3) * 90 + 10, info1 = (1:3) * 70 - 5,                       upper = gs_b, upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,                      lower = gs_b, lpar = c(-1, 0, 0)) %>% mutate(`Computated from` = \"old version\") x1_a %>%    union_all(x1_b) %>%    union_all(x1_c) %>%    union_all(x2) %>%    arrange(Analysis) %>%    group_by(Analysis, Bound) %>%    gt() %>%    tab_style(     style = list(cell_fill(color = \"#d3edeb\")),     locations = cells_body(rows = `Computated from` == \"old version\"))"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"sided-test","dir":"Articles","previous_headings":"Test 3: Developer Tests","what":"1-sided test","title":"Test of the function gs_power_npe","text":"","code":"r = 80 x <- gs_power_npe(theta = 0,                    info = (1:3) * 400,                    binding = FALSE, r = r,                   upper = gs_b, #gs_spending_bound,                    upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF)$upper$bound,                   #list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025)),                   lower = gs_b,                    lpar = rep(-Inf, 3)) %>% filter(Bound == \"Upper\")  y <- gsDesign2:::gs_power_npe_(theta = 0,                    info = (1:3) * 400,                    binding = FALSE, r = r,                   upper = gs_b, #gs_spending_bound,                    upar = gsDesign(k = 3, test.type = 1, sfu = sfLDOF)$upper$bound,                   #list(par = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025)),                   lower = gs_b,                    lpar = rep(-Inf, 3)) %>% filter(Bound == \"Upper\")  z <- gsProbability(k = 3,                     theta = 0,                     n.I = (1:3) * 400,                     b = gsDesign(k = 3, test.type = 1, sfu = sfLDOF)$upper$bound, a = rep(-20, 3), r = r)"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"expect-equal-with-mvtnorm-for-efficacy-and-futility-bounds","dir":"Articles","previous_headings":"Test 4: Independent Tests","what":"Expect equal with mvtnorm for efficacy and futility bounds","title":"Test of the function gs_power_npe","text":"","code":"info <- c(40, 100) r <- info[1] / info[2]  test<-gs_power_npe(theta = 0,                    info = info,                    info0 = NULL,                    binding = FALSE,                    upper = gs_spending_bound,                    upar = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025),                    lower = gs_spending_bound,                    lpar = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.02) )  test1 <- test%>% filter(Bound == \"Upper\") test2 <- test%>% filter(Bound == \"Lower\")  alpha.t <- 0.025 b.ia <- gsDesign::sfLDOF(alpha = alpha.t, t = r) alpha.ia <- b.ia$spend  Pb <- function(alpha.t, alpha.ia, r, b){   temp = mvtnorm::pmvnorm(lower = c(-Inf, b),                            upper = c(qnorm(1-alpha.ia), Inf),                           corr = rbind(c(1, sqrt(r)), c(sqrt(r), 1)))   return(alpha.t - alpha.ia - temp) }  b <- uniroot(Pb, c(1.96, 4), alpha.t = alpha.t, alpha.ia = alpha.ia, r = r)  pb <- 1- pnorm(b$root)  expect_equal(object = test1$Z, expected = c(qnorm(1-alpha.ia),b$root), tolerance = 0.001) expect_equal(object = test1$Probability, expected = cumsum(c(b.ia$spend,pb)), tolerance = 0.001)    beta.t <- 0.02   a.ia <- gsDesign::sfLDOF(alpha = beta.t, t = r)   beta.ia <- a.ia$spend    Pa <- function(beta.t, beta.ia,  r, a){     temp <- mvtnorm::pmvnorm(lower = c(-Inf, qnorm(beta.ia)),                              upper = c(a, Inf),                              corr = rbind(c(1, sqrt(r)), c(sqrt(r), 1)))     return(beta.t -  beta.ia - temp)   }    a <- uniroot(Pa, c(-4, 1.96), beta.t = beta.t, beta.ia = beta.ia, r = r)    pa <- pnorm(a$root)    expect_equal(object = test2$Z, expected = c(qnorm(beta.ia), a$root), tolerance = 0.001)   expect_equal(object = test2$Probability, expected = cumsum(c(a.ia$spend,pa)), tolerance = 0.001)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"expect-equal-with-gsdesigngsprobability-outcome-for-efficacy-bounds","dir":"Articles","previous_headings":"Test 4: Independent Tests","what":"Expect equal with gsDesign::gsProbability outcome for efficacy bounds","title":"Test of the function gs_power_npe","text":"","code":"info <- c(40, 150, 200)  x <- gs_power_npe(theta = .1,                   info = info, binding = FALSE,                   upper = gs_spending_bound,                   upar = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025),                   lower = gs_b,                   lpar = rep(-Inf, 3)) %>% filter(Bound == \"Upper\")  y <- gs_power_npe(theta = .1,                   info = info, binding = FALSE,                   upper = gs_spending_bound,                   upar = list(sf = gsDesign::sfLDOF, param = NULL, total_spend = 0.025),                   lower = gs_b,                   lpar = rep(-Inf, 3)) %>% filter(Bound == \"Upper\")  z <- gsDesign::gsProbability(k = 3, theta = .1,                              n.I = info,                              a = rep(-20, 3),                              b = gsDesign(k = 3, test.type=1, sfu = sfLDOF, n.I = info)$upper$bound)"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"test-5-compare-with-gsdesign-under-information-based-design","dir":"Articles","previous_headings":"","what":"Test 5: Compare with gsDesign under information-based design","title":"Test of the function gs_power_npe","text":"Information-based design useful testing natural parameter \\(\\delta\\) (e.g., treatment difference relevant scale risk difference) variance estimate \\(\\delta\\) unknown. basic canonical form represents information-based design, particularly simple way check corresponding basic calculations sample size, bounds power gs_power_npe() gs_design_npe().","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_gs_power_npe.html","id":"step-1-set-the-design-assumptions","dir":"Articles","previous_headings":"Test 5: Compare with gsDesign under information-based design","what":"Step 1: set the design assumptions","title":"Test of the function gs_power_npe","text":"","code":"k <- 2           # Number of analyses test.type <- 4 alpha <- 0.025   # 1-sided Type I error beta <- 0.15     # Type 2 error (1 - targeted power) astar <- .1 timing <- 0.4    # Timing (information fraction) at interim analyses sfu <- sfHSD     # Efficacy bound spending function sfupar <- -1     # Upper bound spending function parameters, if any sfl <- sfLDPocock# Lower bound spending function, if used (test.type > 2) sflpar <- 0      # Lower bound spending function parameters, if any delta <- 0.1     # Natural parameter difference (assumed value - H0 value) delta1 <- 0.1    # Natural parameter assumed value delta0 <- 0      # Natural parameter difference under H0 endpoint <- 'info' n.fix <- 0"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_tEvents.html","id":"test-1","dir":"Articles","previous_headings":"","what":"Test 1","title":"Test of the function tEvents","text":"test, verify tEvents() AHR().","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x <- AHR(enrollRates = enrollRates, failRates = failRates,           ratio = ratio, totalDuration = 20) cat(\"The number of events by 20 months is \", x$Events, \".\\n\") ## The number of events by 20 months is  208.3641 . y <- tEvents(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, targetEvents = x$Events)  cat(\"The time to get \", x$Events, \" is \", y$Time, \"months.\\n\") ## The time to get  208.3641  is  20 months."},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_tEvents.html","id":"test-2","dir":"Articles","previous_headings":"","what":"Test 2","title":"Test of the function tEvents","text":"","code":"x1 <- tEvents() x2 <- gsDesign2:::tEvents_()  x1 %>%    union_all(x2) %>%    mutate(`function comes from` = c(\"new version\", \"old version\")) %>%    select(`function comes from`, Time, AHR, Events, info, info0) ## # A tibble: 2 × 6 ##   `function comes from`  Time   AHR Events  info info0 ##   <chr>                 <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1 new version            14.9 0.787   150.  36.9  37.5 ## 2 old version            14.9 0.787   150.  36.9  37.5"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/check_tEvents.html","id":"test-3","dir":"Articles","previous_headings":"","what":"Test 3","title":"Test of the function tEvents","text":"","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x1 <- tEvents(enrollRates = enrollRates, failRates = failRates, ratio = ratio, targetEvents = 200) x2 <- gsDesign2:::tEvents_(enrollRates = enrollRates, failRates = failRates, ratio = ratio, targetEvents = 200)  x1 %>%    union_all(x2) %>%    mutate(`function comes from` = c(\"new version\", \"old version\")) %>%    select(`function comes from`, Time, AHR, Events, info, info0) ## # A tibble: 2 × 6 ##   `function comes from`  Time   AHR Events  info info0 ##   <chr>                 <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1 new version            19.2 0.744   200.  48.9  50.0 ## 2 old version            19.2 0.744   200.  48.9  50.0"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"introduction-of-ahr","dir":"Articles","previous_headings":"","what":"Introduction of AHR()","title":"AHR: computes AHR under NPH assumptions and (stratified) populations","text":"AHR() provides geometric average hazard ratio various non-proportional hazards assumptions either single multiple strata studies. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"example-1-un-stratified-population","dir":"Articles","previous_headings":"Usage of AHR()","what":"Example 1: Un-stratified population","title":"AHR: computes AHR under NPH assumptions and (stratified) populations","text":"","code":"enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001) AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) ## # A tibble: 2 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    15 0.694   91.0  22.6  22.7 ## 2    30 0.685  154.   37.9  38.6"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"example-2-stratified-population","dir":"Articles","previous_headings":"Usage of AHR()","what":"Example 2: Stratified population","title":"AHR: computes AHR under NPH assumptions and (stratified) populations","text":"","code":"enrollRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),                       duration = c(2, 10, 4, 4, 8),                       rate = c(5, 10, 0, 3, 6)) failRates <- tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),                     duration = 1,                     failRate = c(.1, .2, .3, .4),                     hr = c(.9, .75, .8, .6),                     dropoutRate = .001) AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) ## # A tibble: 2 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    15 0.733   113.  28.1  28.3 ## 2    30 0.718   166.  41.3  41.5"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_AHR.html","id":"inner-logic-of-ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of AHR()","title":"AHR: computes AHR under NPH assumptions and (stratified) populations","text":"Let’s take un-stratified population example, enrollment rate, failure rates dropout rates Step 1: compute proportion group compute expected events different treatment group, stratum time period, iterate totalDuration Strata. Since example, one analysis time (totalDuration = 30) one stratum (Stratum = \"\"), iterate . one multiple analysis time strata, one can use loop bind results row. Step 2: subset enrollment rates failure rates stratum. Step 3: calculate enrollment rates experimental arm control arm, respectively. Step 4: update failure rate control experimental arm. Step 5: calculate expected number events control experimental eEvents_df(). t column start period, failRate column failure rate period, Events column expected events period. Step 6: combine results together output . Please note , output, info column based following input. alternative hypothesis \\(H_1\\) \\[   \\text{hr}   =   \\left\\{   \\begin{array}{ll}     0.9  & \\text{first 1 month} \\\\     0.75 & \\text{afterwards},   \\end{array}   \\right. \\] info = info1, info1 statistical information \\(H_1\\). notice enrollRates failRates always \\(H_1\\), call info, rather info1.","code":"enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4),                       rate = c(5, 10, 0)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2),                     hr = c(.9, .75),                     dropoutRate = .001)  ratio <- 2  totalDuration <- 30 Qe <- ratio / (1 + ratio) Qc <- 1 - Qe ## The proportion of the experimental arm is  0.6666667 ## The proportion of the control arm is  0.3333333 td <- totalDuration s <- \"All\" enroll <- enrollRates %>% filter(Stratum == s) fail <- failRates %>% filter(Stratum == s) enroll_c <- enroll %>% mutate(rate = rate * Qc) enroll_e <- enroll %>% mutate(rate = rate * Qe) fail_c <- fail fail_e <- fail %>% mutate(failRate = failRate * hr) events_c <- eEvents_df(enrollRates = enroll_c, failRates = fail_c, totalDuration = td, simple = FALSE) events_e <- eEvents_df(enrollRates = enroll_e, failRates = fail_e, totalDuration = td, simple = FALSE) ## The expected number of events in the control arm is ## # A tibble: 3 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0      0.1   3.49 ## 2     1      0.2  30.6  ## 3     2      0.2   1.98 ## The expected number of events in the experimental arm is ## # A tibble: 3 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0     0.09   6.31 ## 2     1     0.15  57.2  ## 3     2     0.15   6.86 # combine control and experimental events <- rbind(events_c %>% mutate(Treatment = \"Control\"),                 events_e %>% mutate(Treatment = \"Experimental\")) %>%           arrange(t, Treatment) %>%            ungroup() %>%            # recompute HR, events, info by period           group_by(t) %>%           summarize(Stratum = s,                      info = (sum(1 / Events))^(-1),                     Events = sum(Events),                      HR = last(failRate) / first(failRate)) %>%            # compute info0           mutate(Time = td,                   lnhr = log(HR),                   info0 = Events * Qc * Qe) %>%           ungroup() %>%                       group_by(Time, Stratum, HR) %>%           summarize(t = min(t),                      Events = sum(Events),                      info0 = sum(info0),                      info = sum(info)) %>%           # pool time period together           group_by(Time) %>%           summarize(AHR = exp(sum(log(HR) * Events) / sum(Events)),                     Events = sum(Events),                     info = sum(info),                     info0 = sum(info0)) ## The overall expected number of events over the time is ## # A tibble: 1 × 5 ##    Time   AHR Events  info info0 ##   <dbl> <dbl>  <dbl> <dbl> <dbl> ## 1    30 0.763   106.  23.7  23.6 enrollRates <- tibble(Stratum = \"All\",                       duration = c(2, 10, 4),                       rate = c(5, 10, 0)) failRates <- tibble(Stratum = \"All\",                     duration = 1,                     failRate = c(.1, .2),                     hr = c(.9, .75),                     dropoutRate = .001)"},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eAccural.html","id":"example-1","dir":"Articles","previous_headings":"Use cases of eAccrual()","what":"Example 1","title":"eAccrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times.","text":"enrollment first 3 months, exactly \\(3 \\times 5 = 15\\).","code":"eAccrual(x = 3,          enrollRates = tibble(duration = c(3, 3, 18), rate = c(5, 10, 20))) ## [1] 15"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eAccural.html","id":"example-2","dir":"Articles","previous_headings":"Use cases of eAccrual()","what":"Example 2","title":"eAccrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times.","text":"enrollment first 6 months, exactly \\(3 \\times 5 + 3 \\times 10 = 45\\).","code":"eAccrual(x = 6,           enrollRates = tibble(duration = c(3, 3, 18), rate = c(5, 10, 20))) ## [1] 45"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eAccural.html","id":"example-3","dir":"Articles","previous_headings":"Use cases of eAccrual()","what":"Example 3","title":"eAccrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times.","text":"enrollment first 24 months, exactly \\(3 \\times 5 + 3 \\times 10 + 18 * 20 = 405\\).","code":"eAccrual(x = 24,           enrollRates = tibble(duration = c(3, 3, 18), rate = c(5, 10, 20))) ## [1] 405"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eAccural.html","id":"example-4","dir":"Articles","previous_headings":"Use cases of eAccrual()","what":"Example 4","title":"eAccrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times.","text":"enrollment 24 months, 24 months, since enrollment stopped.","code":"eAccrual(x = 25,           enrollRates = tibble(duration = c(3, 3, 18), rate = c(5, 10, 20))) ## [1] 405"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eAccural.html","id":"example-5","dir":"Articles","previous_headings":"Use cases of eAccrual()","what":"Example 5","title":"eAccrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times.","text":"Instead compute enrolled subjects one time point one time point, can also compute .","code":"eAccrual(x = c(3, 6, 24, 25),           enrollRates = tibble(duration = c(3, 3, 18), rate = c(5, 10, 20))) ## [1]  15  45 405 405"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eAccural.html","id":"inner-logic-of-eaccrual","dir":"Articles","previous_headings":"","what":"Inner Logic of eAccrual()","title":"eAccrual: computes the expected cumulative enrollment (accrual) given a set of piecewise constant enrollment rates and times.","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"introduction-of-eevents_df","dir":"Articles","previous_headings":"","what":"Introduction of eEvents_df","title":"eEvents_df: compute expected number of events at 1 time point","text":"eEvents_df() computes expected number events given analysis time strata assumption piecewise model: piecewise constant enrollment rates piecewise exponential failure rates piecewise censoring rates. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time. df eEvents_df() short data frame, since output data frame.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-1-single-enroll-single-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 1: Single Enroll + Single Fail Period","title":"eEvents_df: compute expected number of events at 1 time point","text":"","code":"enrollRates <- tibble(duration = 10, rate = 10) failRates <- tibble(duration = 100, failRate = log(2) / 6, dropoutRate = .01) totalDuration <- 22  eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE) ## # A tibble: 1 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0    0.116   80.4"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-2-multiple-enroll-single-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 2: Multiple Enroll + Single Fail Period","title":"eEvents_df: compute expected number of events at 1 time point","text":"","code":"enrollRates <- tibble(duration = c(5, 5), rate = c(10, 20)) failRates <- tibble(duration = 100, failRate = log(2)/6, dropoutRate = .01) totalDuration <- 22  eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE) ## # A tibble: 1 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0    0.116   119."},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-3-signle-enroll-multiple-fail-period","dir":"Articles","previous_headings":"Use Cases","what":"Example 3: Signle Enroll + Multiple Fail Period","title":"eEvents_df: compute expected number of events at 1 time point","text":"","code":"enrollRates <- tibble(duration = 10, rate = 10) failRates <- tibble(duration = c(20, 80), failRate = c(log(2)/6, log(2)/4), dropoutRate = .01) totalDuration <- 22  eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE) ## # A tibble: 2 × 3 ##       t failRate Events ##   <dbl>    <dbl>  <dbl> ## 1     0    0.116 80.2   ## 2    20    0.173  0.250"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"example-4-multiple-duration","dir":"Articles","previous_headings":"Use Cases","what":"Example 4: Multiple Duration","title":"eEvents_df: compute expected number of events at 1 time point","text":"","code":"enrollRates <- tibble(duration = 10, rate = 10) failRates <- tibble(duration = 100, failRate = log(2) / 6, dropoutRate = .01) totalDuration <- c(2, 22)  try(eEvents_df(enrollRates = enrollRates, failRates = failRates, totalDuration = totalDuration, simple = FALSE)) ## Error in eEvents_df(enrollRates = enrollRates, failRates = failRates,  :  ##   gsDesign2: totalDuration in `events_df()` must be a numeric number!"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_eEvents_df.html","id":"inner-logic-of-eevents_df","dir":"Articles","previous_headings":"","what":"Inner Logic of eEvents_df()","title":"eEvents_df: compute expected number of events at 1 time point","text":"Step 1: set analysis time. Step 2: set enrollment rates.  Step 3: set failure rates dropout rates.   Given piecewise enrollment rates, failure rates, dropout rates, time line divided several parts: \\((0, 5]\\) (5 change point enrollment rates); \\((5, 10]\\) (10 another change point enrollment rates); \\((10, 20]\\) (20 change point failure rates); \\((20, 50]\\) (50 analysis time); \\((50, \\infty]\\) (analysis time).  Given sub-intervals, objective calculate expected number events sub-intervals. Step 4: divide time line enrollments Step 5: divide time line failure & dropout rates df_2, one needs discriminate analysis time (totalDuration = 50) beyond total failure rate duration. Step 6: divide time line considering change points enrollment, failure, dropout rates. find lots NA, can imputed piecewise model. Step 7: compute expected number events sub-intervals following technical details vignette ``computing expected events interval risk’’ Step 8: output results","code":"totalDuration <- 50 enrollRates <- tibble(duration = c(5, 5), rate = c(10, 20))  # create a step function (sf) to define enrollment rates over time sf.enrollRate <- stepfun(c(0, cumsum(enrollRates$duration)),                          c(0, enrollRates$rate, 0),                          right = FALSE)  plot(sf.enrollRate,       xlab = \"duration\", ylab = \"enrollment rates\",       main = \"Piecewise enrollment rate over time\", xlim = c(-0.01, 21)) failRates <- tibble(duration = c(20, 80), failRate = c(0.1, 0.2), dropoutRate = .01)  # get the time points where the failure rates change startFail <- c(0, cumsum(failRates$duration))  # plot the piecewise failure rates sf.failRate <- stepfun(startFail,                        c(0, failRates$failRate, last(failRates$failRate)),                        right = FALSE) plot(sf.failRate,       xlab = \"duration\", ylab = \"failure rates\",       main = \"Piecewise failure rate over time\", xlim = c(-0.01, 101)) # plot the piecewise dropout rate sf.dropoutRate <- stepfun(startFail,                           c(0, failRates$dropoutRate, last(failRates$dropoutRate)),                           right = FALSE) plot(sf.dropoutRate,       xlab = \"duration\", ylab = \"dropout rates\",       main = \"Piecewise dropout rate over time\", xlim = c(-0.01, 101)) df_1 <- tibble(startEnroll = c(0, cumsum(enrollRates$duration)),                endFail = totalDuration - startEnroll,                rate = c(enrollRates$rate, 0)) df_2 <- tibble(endFail = cumsum(failRates$duration),                startEnroll = totalDuration - endFail,                failRate = failRates$failRate,                dropoutRate = failRates$dropoutRate) # if the analysis time is after the total failure rate duration if(sum(failRates$duration) < totalDuration){   df_2 <- df_2[-nrow(df_2), ] }else{   df_2 <- df_2 %>% filter(startEnroll > 0) } df <- full_join(df_1, df_2, by = c(\"startEnroll\", \"endFail\")) %>% arrange(endFail) df <- df %>% mutate(endEnroll = lag(startEnroll, default = as.numeric(totalDuration)),                     startFail = lag(endFail, default = 0),                     duration = endEnroll - startEnroll,                     failRate = sf.failRate(startFail),                     dropoutRate = sf.dropoutRate(startFail),                     enrollRate = sf.enrollRate(startEnroll)) %>%               select(-rate) # create 2 auxiliary variable for failure & dropout rate              # q: number of expected events in a sub-interval              # Q: cumulative product of q (pool all sub-intervals) df <- df %>% mutate(q = exp(-duration * (failRate + dropoutRate)),                     Q = lag(cumprod(q), default = 1)) %>%              arrange(desc(startFail)) %>%              # create another 2 auxiliary variable for enroll rate              # g: number of expected subjects in a sub-interval              # G: cumulative sum of g (pool all sub-intervals)              mutate(g = enrollRate * duration,                     G = lag(cumsum(g), default = 0)) %>%              arrange(startFail) %>%              # compute expected events as nbar in a sub-interval              mutate(d = ifelse(failRate == 0, 0, Q * (1 - q) * failRate / (failRate + dropoutRate)),                     nbar = ifelse(failRate == 0, 0, G * d + (failRate * Q * enrollRate) / (failRate + dropoutRate) * (duration - (1 - q) / (failRate + dropoutRate)))) sf.startFail <- stepfun(startFail, c(0, startFail), right = FALSE) df <- df %>%    transmute(t = endFail, failRate = failRate, Events = nbar, startFail = sf.startFail(startFail)) %>%    group_by(startFail) %>%   summarize(failRate = first(failRate), Events = sum(Events)) %>%   mutate(t = startFail) %>%    select(\"t\", \"failRate\", \"Events\")  df %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"introduction-of-gs_b","dir":"Articles","previous_headings":"","what":"Introduction of gs_b()","title":"gs_b: specify fixed boundaries in group sequential designs","text":"gs_b() can used derive fixed boundary fixed/group sequential design. usually used upper = ... lower = ... arguments + gs_power_npe() + gs_design_npe() + gs_power_ahr() + gs_design_ahr() + gs_power_wlr() + gs_design_wlr() + gs_power_combo() + gs_design_combo()","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"example-1","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 1","title":"gs_b: specify fixed boundaries in group sequential designs","text":"Assume group sequential design 3 analysis, one can input upper bound vector c(4, 3, 2) using gs_b() follows.","code":"gs_b(par = 4:2) ## [1] 4 3 2"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"example-2","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 2","title":"gs_b: specify fixed boundaries in group sequential designs","text":"example, one can assign upper bound second analysis ","code":"gs_b(par = 4:2, k = 2) ## [1] 3"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"example-3","dir":"Articles","previous_headings":"Usage of gs_b()","what":"Example 3","title":"gs_b: specify fixed boundaries in group sequential designs","text":"Generate efficacy bound using spending function. Use Lan-DeMets spending approximation O’Brien-Fleming bound 50%, 75% 100% final spending","code":"# information fraction IF <- c(.5, .75, 1) # Lan-DeMets spending approximation of O'Brien-Fleming par <- gsDesign::gsDesign(alpha = .025, k = length(IF),                            test.type = 1, sfu = gsDesign::sfLDOF,                            timing = IF)$upper$bound gs_b(par = par) ## [1] 2.962588 2.359018 2.014084"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_b.html","id":"inner-logic-of-gs_b","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_b()","title":"gs_b: specify fixed boundaries in group sequential designs","text":"gs_b short function 2 key arguments: par = ... k = ...","code":"if(is.null(k)){   return(par) }else{    return(par[k]) }"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"introduction-of-gs_info_ahr","dir":"Articles","previous_headings":"","what":"Introduction of gs_info_ahr()","title":"gs_info_ahr: compute statistical information by the AHR method","text":"tEvents() calculate analysis time (Time output), number events (Events output), average hazard ratio (AHR outputs), effect size (theta output), statistical information (info info0 output) using average hazard ratio model. aforementioned calculation based piecewise model: + piecewise constant enrollment rates + piecewise exponential failure rates + piecewise censoring rates.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"example-1","dir":"Articles","previous_headings":"Use Cases","what":"Example 1","title":"gs_info_ahr: compute statistical information by the AHR method","text":"example, input target number events events = ..., derive time events arrived.","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  gs_info_ahr(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, events = c(50, 80, 100)) ## # A tibble: 3 × 7 ##   Analysis  Time Events   AHR theta  info info0 ##      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1  8.29   50.0 0.850 0.163  12.4  12.5 ## 2        2 10.5    80.0 0.825 0.193  19.7  20.0 ## 3        3 11.9   100.  0.812 0.208  24.6  25.0"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"example-2","dir":"Articles","previous_headings":"Use Cases","what":"Example 2","title":"gs_info_ahr: compute statistical information by the AHR method","text":"example, input analysis time analysisTimes = ..., derive number events analysis time.","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  gs_info_ahr(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, analysisTimes = c(10, 15, 20)) ## # A tibble: 3 × 7 ##   Analysis  Time Events   AHR theta  info info0 ##      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1    10   72.4 0.831 0.186  17.9  18.1 ## 2        2    15  151.  0.786 0.241  37.2  37.8 ## 3        3    20  208.  0.738 0.304  51.0  52.1"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"example-3","dir":"Articles","previous_headings":"Use Cases","what":"Example 3","title":"gs_info_ahr: compute statistical information by the AHR method","text":"example, input analysisTimes = ... events = .... case, one see + derived analysis time (Time column) \\(\\geq\\) input analysisTimes + derived number event (Events column) \\(\\geq\\) input events","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  gs_info_ahr(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, analysisTimes = c(10, 15, 20), events = c(80,  # > events in example 2                                                                       140, # < > events in example 2                                                                       220  # > events in example 2                                                                       )) ## # A tibble: 3 × 7 ##   Analysis  Time Events   AHR theta  info info0 ##      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1  10.5   80.0 0.825 0.193  19.7  20.0 ## 2        2  15    151.  0.786 0.241  37.2  37.8 ## 3        3  21.2  220.  0.730 0.315  53.8  55.0"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"inner-logic-of-gs_info_ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_info_ahr()","title":"gs_info_ahr: compute statistical information by the AHR method","text":"explain inner logic gs_info_ahr(), discuss 3 scenario. input analysisTimes input events input analysisTimes events","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"scenario-1-only-input-analysistimes","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 1: only input analysisTimes","title":"gs_info_ahr: compute statistical information by the AHR method","text":"analysisTimes = ... input, essentially, gs_info_ahr() uses AHR() calculate number events analysisTimes. exactly output gs_info_ahr():","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 analysisTimes <- c(10, 15, 20)  AHR(enrollRates = enrollRates, failRates = failRates,      ratio = ratio, totalDuration = analysisTimes) %>%    mutate(theta = -log(AHR), Analysis = 1 : length(analysisTimes)) %>%    select(Analysis, Time, Events, AHR, theta, info, info0) %>%    gt() gs_info_ahr(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, analysisTimes = analysisTimes) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"scenario-2-only-input-events","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 2: only input events","title":"gs_info_ahr: compute statistical information by the AHR method","text":"events = ... input, essentially, gs_info_ahr() uses tEvents() calculate time events arrived. exactly output gs_info_ahr():","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 events <- c(70, 150, 200)  ans <- NULL for(i in seq_along(events)){   ans_new <- gsDesign2::tEvents(enrollRates = enrollRates, failRates = failRates,                                  ratio = ratio, targetEvents = events[i])   ans <- rbind(ans, ans_new) }  ans %>%    mutate(theta = -log(AHR), Analysis = 1 : length(analysisTimes)) %>%    select(Analysis, Time, Events, AHR, theta, info, info0) %>%    gt() gs_info_ahr(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, events = events) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_info_ahr.html","id":"scenario-3-both-input-analysistimes-and-events","dir":"Articles","previous_headings":"Inner Logic of gs_info_ahr()","what":"Scenario 3: both input analysisTimes and events","title":"gs_info_ahr: compute statistical information by the AHR method","text":"analysisTimes = ... events = ... input, gs_info_ahr() uses AHR() tEvents(). way, guaranteed + derived number event (Events column) \\(\\geq\\) input events + derived analysis time (Time column) \\(\\geq\\) input analysisTimes exactly output gs_info_ahr():","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 analysisTimes <- c(10, 15, 20) events <- c(70, 150, 200)  ans <- NULL  # first, use `AHR()` to calculate the number of events at the input `analysisTimes` ans <- AHR(enrollRates = enrollRates, failRates = failRates,             ratio = ratio, totalDuration = analysisTimes)  # second, compare if the events derived above meet the targeted number of events input in `events` for(i in seq_along(events)){   if (ans$Events[i] < events[i]){     ans[i,] <- tEvents(enrollRates = enrollRates, failRates = failRates,                         ratio = ratio, targetEvents = events[i])   } }  ans %>%    mutate(theta = -log(AHR), Analysis = 1 : length(analysisTimes)) %>%    select(Analysis, Time, Events, AHR, theta, info, info0) %>%    gt() gs_info_ahr(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, events = events, analysisTimes = analysisTimes) %>% gt()"},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_ahr.html","id":"example-1","dir":"Articles","previous_headings":"Use cases of gs_power_ahr()","what":"Example 1","title":"gs_power_ahr: computes power using average hazard ratio under non-proportional hazards","text":"","code":"x <- gs_power_ahr(enrollRates = tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9)),                   failRates = tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18),                                       hr = c(.9, .6), dropoutRate = rep(.001, 2)),                   analysisTimes = c(12, 24, 36), events = NULL,                   binding = TRUE,                   upper = gs_spending_bound,                   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),                   lower = gs_spending_bound,                   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) x ## $enrollRates ## # A tibble: 3 × 3 ##   Stratum duration  rate ##   <chr>      <dbl> <dbl> ## 1 All            2     3 ## 2 All            2     6 ## 3 All           10     9 ##  ## $failRates ## # A tibble: 2 × 5 ##   Stratum duration failRate    hr dropoutRate ##   <chr>      <dbl>    <dbl> <dbl>       <dbl> ## 1 All            3   0.0770   0.9       0.001 ## 2 All          100   0.0385   0.6       0.001 ##  ## $bounds ## # A tibble: 6 × 7 ##   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` ##      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> ## 1        1 Upper   0.000370     0.0000538  3.87          0.180   0.0000538 ## 2        1 Lower   0.0000612    0.0000554 -3.87          5.54    1.00      ## 3        2 Upper   0.116        0.00921    2.36          0.510   0.00919   ## 4        2 Lower   0.00907      0.00906   -2.36          1.96    0.991     ## 5        3 Upper   0.324        0.0250     2.01          0.610   0.0222    ## 6        3 Lower   0.0250       0.0250    -2.01          1.64    0.978     ##  ## $analysis ## # A tibble: 3 × 10 ##   Analysis  Time     N Events   AHR theta  info info0    IF   IF0 ##      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1    12    90   20.4 0.811 0.210  5.03  5.10 0.309 0.308 ## 2        2    24   108   49.1 0.715 0.335 12.0  12.3  0.738 0.741 ## 3        3    36   108   66.2 0.683 0.381 16.3  16.6  1     1     ##  ## attr(,\"class\") ## [1] \"ahr\"       \"gs_design\" \"list\""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_ahr.html","id":"inner-logic-of-gs_power_ahr","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_power_ahr()","title":"gs_power_ahr: computes power using average hazard ratio under non-proportional hazards","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"introduction-of-gs_power_npe","dir":"Articles","previous_headings":"","what":"Introduction of gs_power_npe()","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"gs_power_npe() derives group sequential bounds boundary crossing probabilities design. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires + treatment effect (theta, theta1) + statistical information analysis (info, info0, info1) + method deriving bounds, fixed bounds spending (upper, upar, lower, lpar). routine enables two things available gsDesign package: non-constant effect, flexibility boundary selection.","code":""},{"path":[]},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"no-futility-bound","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"no futility bound","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"# Same fixed efficacy bounds,  (i.e., non-binding bound), null hypothesis gs_power_npe(   theta = rep(0, 3),   info = (1:3) * 40,   upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,   lpar = rep(-Inf, 3)) %>%   filter(Bound == \"Upper\") %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"with-futility-bound","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"with futility bound","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"# Fixed bound gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   upper = gs_b,   upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,   lower = gs_b,   lpar = c(-1, 0, 0)) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"futility-only-at-analysis-1","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 1: Fixed bound","what":"futility only at analysis 1","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   upper = gs_b,   upar = c(Inf, 3, 2),   lower = gs_b,   lpar = c(qnorm(.1), -Inf, -Inf)) %>% gt()"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"lower-spending-based-on-non-zero-effect","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 2: spending bounds","what":"lower spending based on non-zero effect","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"gs_power_npe(   theta = c(.1, .2, .3), # non-zero effect   info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) ## # A tibble: 6 × 10 ##   Analysis Bound       Z Probability theta theta1    IF  info info0 info1 ##      <int> <chr>   <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> ## 1        1 Upper  3.71       0.00104   0.1    0.1 0.333    40    40    40 ## 2        2 Upper  2.51       0.235     0.2    0.2 0.667    80    80    80 ## 3        3 Upper  1.99       0.883     0.3    0.3 1       120   120   120 ## 4        1 Lower -1.36       0.0230    0.1    0.1 0.333    40    40    40 ## 5        2 Lower  0.0726     0.0552    0.2    0.2 0.667    80    80    80 ## 6        3 Lower  1.86       0.100     0.3    0.3 1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"sided-symmetric-spend","dir":"Articles","previous_headings":"Usage of gs_power_npe() > Example 2: spending bounds","what":"2-sided symmetric spend","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"","code":"x <- gs_power_npe(   theta = rep(0, 3),   info = (1:3) * 40,   # typically, 2-sided bounds are binding   binding = TRUE,   upper = gs_spending_bound,   # O'Brien-Fleming spending   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))  x %>% gt() # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upar = (x %>% filter(Bound == \"Upper\"))$Z,   lpar = -(x %>% filter(Bound == \"Upper\"))$Z) %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_power_npe.html","id":"inner-logic-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_spending_bound()","title":"gs_power_npe: derives bounds and crossing probabilities for group sequential designs under NPH assumptions","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_spending_bound.html","id":"introduction-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Introduction of gs_spending_bound()","title":"gs_spending_bound: compute spending boundary in group sequential design","text":"gs_spending_bound() can used derive spending boundary group sequential design. usually used upper = ... lower = ... arguments + gs_power_npe() + gs_design_npe() + gs_power_ahr() + gs_design_ahr() + gs_power_wlr() + gs_design_wlr() + gs_power_combo() + gs_design_combo()","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_spending_bound.html","id":"example-1","dir":"Articles","previous_headings":"Usage of gs_spending_bound()","what":"Example 1","title":"gs_spending_bound: compute spending boundary in group sequential design","text":"","code":"info <- (1:3) * 10 IF <- info / max(info) k <- length(IF)  # 1st analysis a1 <- gs_spending_bound(k = 1, efficacy = FALSE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = NULL)  b1 <- gs_spending_bound(k = 1, efficacy = TRUE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = NULL) cat(\"The (lower, upper) boundary at the 1st analysis is (\", a1, \", \", b1, \").\\n\") ## The (lower, upper) boundary at the 1st analysis is ( -3.710303 ,  3.710303 ). # 2st analysis a2 <- gs_spending_bound(k = 2, efficacy = FALSE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = h1(r = 18, theta = 0,  I = info[1],  a = a1, b = b1))  b2 <- gs_spending_bound(k = 2, efficacy = TRUE, theta = 0,                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),                          hgm1 = h1(r = 18, theta = 0,  I = info[1],  a = a1, b = b1)) cat(\"The upper boundary at the 2nd analysis is (\", a2, \", \", b2, \").\\n\") ## The upper boundary at the 2nd analysis is ( -2.511434 ,  2.511434 ). # 3nd analysis # a3 <- gs_spending_bound(k = 2, efficacy = FALSE, theta = 0, #                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),  #                         hgm1 = hupdate(r = 18, theta = 0,  I = info[2],  a = a2, b = b2,  #                                        thetam1 = 0,  Im1 = info[2],   #                                        gm1 = h1(r = 18, theta = 1,  I = info[1],  a = a1, b = b1))) #  # b3 <- gs_spending_bound(k = 2, efficacy = TRUE, theta = 0, #                         par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, timing = IF, param = NULL),  #                         hgm1 = hupdate(r = 18, theta = 0,  I = info[2],  a = a2, b = b2,  #                                        thetam1 = 0,  Im1 = info[2],   #                                        gm1 = h1(r = 18, theta = 0,  I = info[1],  a = a1, b = b1))) # cat(\"The upper boundary at the 2nd analysis is (\", a3, \", \", b3, \").\\n\")"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_gs_spending_bound.html","id":"inner-logic-of-gs_spending_bound","dir":"Articles","previous_headings":"","what":"Inner Logic of gs_spending_bound()","title":"gs_spending_bound: compute spending boundary in group sequential design","text":"TODO","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"introduction-of-tevents","dir":"Articles","previous_headings":"","what":"Introduction of tEvents","title":"tEvents: compute time when a targeted number of events is made","text":"tEvents() predicts time targeted events made. designed twins AHR(): matches input/output format AHR().","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"example-1","dir":"Articles","previous_headings":"Use Cases","what":"Example 1:","title":"tEvents: compute time when a targeted number of events is made","text":"","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x <- tEvents(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, targetEvents = 200)  x %>% gt()"},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"example-2","dir":"Articles","previous_headings":"Use Cases","what":"Example 2:","title":"tEvents: compute time when a targeted number of events is made","text":"example, verify tEvents() AHR().","code":"enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1  x <- AHR(enrollRates = enrollRates, failRates = failRates,           ratio = ratio, totalDuration = 20) cat(\"The number of events by 20 months is \", x$Events, \".\\n\") ## The number of events by 20 months is  208.3641 . y <- tEvents(enrollRates = enrollRates, failRates = failRates,              ratio = ratio, targetEvents = x$Events)  cat(\"The time to get \", x$Events, \" is \", y$Time, \"months.\\n\") ## The time to get  208.3641  is  20 months."},{"path":"https://littlebeannie.github.io/gsDesign2/articles/usage_tEvents.html","id":"inner-logic-of-tevents","dir":"Articles","previous_headings":"","what":"Inner Logic of tEvents()","title":"tEvents: compute time when a targeted number of events is made","text":"inner logic tEvents() uniroot AHR() totalDuration. Step 1: find difference AHR() different values totalDuration. Step 2: uniroot AHR() totalDuration.","code":"foo <- function(x){   ans <- AHR(enrollRates = enrollRates, failRates = failRates,               totalDuration = x, ratio = ratio)$Events - targetEvents   return(ans) } enrollRates <- tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18), hr = c(.9, .6), dropoutRate = rep(.001, 2)) ratio <- 1 targetEvents <- 200  cat(\"The difference between `targetEvents = 200` and the events after 30 months is \", foo(30), \".\\n\") ## The difference between `targetEvents = 200` and the events after 30 months is  92.45484 . res <- uniroot(foo, interval = c(0.01, 100))  ans <- AHR(enrollRates = enrollRates, failRates = failRates,             totalDuration = res$root, ratio = ratio) cat(\"After \", ans$Time, \" months, there will be \", targetEvents, \" events .\\n\") ## After  19.16437  months, there will be  200  events ."},{"path":"https://littlebeannie.github.io/gsDesign2/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Keaven Anderson. Author, maintainer. Yujie Zhao. Author. Merck Sharp & Dohme Corp. Copyright holder.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Anderson K, Zhao Y (2022). gsDesign2: Group sequential design non-constant effect. https://github.com/LittleBeannie/gsDesign2, https://littlebeannie.github.io/gsDesign2/.","code":"@Manual{,   title = {gsDesign2: Group sequential design with non-constant effect},   author = {Keaven Anderson and Yujie Zhao},   year = {2022},   note = {https://github.com/LittleBeannie/gsDesign2, https://littlebeannie.github.io/gsDesign2/}, }"},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/index.html","id":"objective","dir":"","previous_headings":"","what":"Objective","title":"Group sequential design with non-constant effect","text":"goal gsDesign2 enable fixed group sequential design non-proportional hazards. Piecewise constant enrollment, failure rates dropout rates stratified population available enable highly flexible enrollment, time--event time--dropout assumptions. Substantial flexibility top gsDesign package intended selecting boundaries. work progress, substantial capabilities enabled. Comments usability features encouraged development version package. goal gsDesign2 enable group sequential trial design time--event endpoints non-proportional hazards assumptions. package still maturing; package functions become stable, likely included gsDesign2 package.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Group sequential design with non-constant effect","text":"can install gsDesign2 :","code":"remotes::install_github(\"LittleBeannie/gsDesign2\")"},{"path":"https://littlebeannie.github.io/gsDesign2/index.html","id":"use-cases","dir":"","previous_headings":"","what":"Use cases","title":"Group sequential design with non-constant effect","text":"…","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":null,"dir":"Reference","previous_headings":"","what":"Average hazard ratio under non-proportional hazards (test version) — AHR","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"AHR() provides geometric average hazard ratio various non-proportional hazards assumptions either single multiple strata studies. piecewise exponential distribution allows simple method specify distribution enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"","code":"AHR(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   totalDuration = 30,   ratio = 1,   simple = TRUE )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"enrollRates Piecewise constant enrollment rates stratum time period. failRates Piecewise constant control group failure rates, duration piecewise constant period, hazard ratio experimental vs control, dropout rates stratum time period. totalDuration Total follow-start enrollment data cutoff; can single value vector positive numbers. ratio ratio experimental control randomization. simple logical; TRUE (default), value input totalDuration overall event count, statistical information average hazard ratio given; FALSE, hazard ratio, expected events statistical information produced stratum underlying hazard ratio.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"tibble Time (totalDuration), AHR (average hazard ratio), Events (expected number events), info (information given scenarios), info0 (information related null hypothesis) value totalDuration input; simple=FALSE, Stratum t (beginning constant HR period) also returned HR returned instead AHR","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/AHR.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Average hazard ratio under non-proportional hazards (test version) — AHR","text":"","code":"# Example: default AHR() #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    30 0.695   58.5  14.3  14.6  # Example: default with multiple analysis times (varying totalDuration)  AHR(totalDuration = c(15, 30)) #> # A tibble: 2 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 0.786   30.3  7.44  7.57 #> 2    30 0.695   58.5 14.3  14.6   # Stratified population enrollRates <- tibble::tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 3)),                               duration = c(2, 10, 4, 4, 8),                               rate = c(5, 10, 0, 3, 6)) failRates <- tibble::tibble(Stratum = c(rep(\"Low\", 2), rep(\"High\", 2)),                             duration = 1,                             failRate = c(.1, .2, .3, .4),                             hr = c(.9, .75, .8, .6),                             dropoutRate = .001) AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30)) #> # A tibble: 2 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 0.733   113.  28.1  28.3 #> 2    30 0.718   166.  41.3  41.5  # Same example, give results by strata and time period AHR(enrollRates = enrollRates, failRates = failRates, totalDuration = c(15, 30), simple = FALSE) #> # A tibble: 8 × 7 #> # Groups:   Time, Stratum [4] #>    Time Stratum     t    HR Events  info info0 #>   <dbl> <chr>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    15 High        0  0.8   12.1   2.99  3.02 #> 2    15 High        1  0.6   23.1   5.72  5.78 #> 3    15 Low         0  0.9    9.96  2.48  2.49 #> 4    15 Low         1  0.75  68.1  16.9  17.0  #> 5    30 High        0  0.8   14.2   3.51  3.54 #> 6    30 High        1  0.6   45.2  11.2  11.3  #> 7    30 Low         0  0.9    9.96  2.48  2.49 #> 8    30 Low         1  0.75  96.8  24.1  24.2"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eAccrual.html","id":null,"dir":"Reference","previous_headings":"","what":"Piecewise constant expected accrual — eAccrual","title":"Piecewise constant expected accrual — eAccrual","text":"eAccrual() computes expected cumulative enrollment (accrual) given set piecewise constant enrollment rates times.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eAccrual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Piecewise constant expected accrual — eAccrual","text":"","code":"eAccrual(   x = 0:24,   enrollRates = tibble(duration = c(3, 3, 18), rate = c(5, 10, 20)) )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eAccrual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Piecewise constant expected accrual — eAccrual","text":"x times enrollment computed. enrollRates Piecewise constant enrollment rates expressed tibble duration piecewise constant period rate enrollment period.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eAccrual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Piecewise constant expected accrual — eAccrual","text":"vector expected cumulative enrollment specified times.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eAccrual.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Piecewise constant expected accrual — eAccrual","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eAccrual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Piecewise constant expected accrual — eAccrual","text":"","code":"# Example: default eAccrual() #>  [1]   0   5  10  15  25  35  45  65  85 105 125 145 165 185 205 225 245 265 285 #> [20] 305 325 345 365 385 405"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":null,"dir":"Reference","previous_headings":"","what":"Expected events observed under piecewise exponential model — eEvents_df","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"eEvents_df computes expected events time strata assumption piecewise constant enrollment rates piecewise exponential failure censoring rates. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rates changes time. main purpose may generate trial can analyzed single point time using group sequential methods, routine can also used simulate adaptive trial design. intent enable sample size calculations non-proportional hazards assumptions stratified populations.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"","code":"eEvents_df(   enrollRates = tibble::tibble(duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble::tibble(duration = c(3, 100), failRate = log(2)/c(9, 18),     dropoutRate = rep(0.001, 2)),   totalDuration = 25,   simple = TRUE )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"enrollRates Enrollment rates; see details examples failRates Failure rates dropout rates period totalDuration Total follow-start enrollment data cutoff simple default (TRUE), return numeric expected number events, otherwise tibble described .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"default simple=TRUE return total expected number events real number. Otherwise, simple=FALSE tibble returned following variables period specified 'failRates': t start period, failRate failure rate period Events expected events period, records returned tibble correspond input tibble  failRates.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"periods generally supplied output input. intent enable expected event calculations tidy format maximize flexibility variety purposes.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/reference/eEvents_df.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Expected events observed under piecewise exponential model — eEvents_df","text":"","code":"library(tibble) library(gsDesign2)  # Default arguments, simple output (total event count only) eEvents_df() #> [1] 57.3537  # Event count by time period eEvents_df(simple = FALSE) #> # A tibble: 2 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0   0.0770   22.2 #> 2     3   0.0385   35.1  # Early cutoff eEvents_df(totalDuration = .5) #> [1] 0.02850923  # Single time period example eEvents_df(enrollRates = tibble(duration = 10,rate = 10),            failRates = tibble(duration=100, failRate = log(2) / 6 ,dropoutRate = .01),            totalDuration = 22,            simple = FALSE) #> # A tibble: 1 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0    0.116   80.4  # Single time period example, multiple enrollment periods eEvents_df(enrollRates = tibble(duration = c(5,5), rate = c(10, 20)),            failRates = tibble(duration = 100, failRate = log(2)/6, dropoutRate = .01),            totalDuration = 22, simple = FALSE) #> # A tibble: 1 × 3 #>       t failRate Events #>   <dbl>    <dbl>  <dbl> #> 1     0    0.116   119."},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gsDesign2-package.html","id":null,"dir":"Reference","previous_headings":"","what":"gsDesign2: Group sequential design with non-constant effect — gsDesign2-package","title":"gsDesign2: Group sequential design with non-constant effect — gsDesign2-package","text":"Basic group sequential design computations extended.","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gsDesign2-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"gsDesign2: Group sequential design with non-constant effect — gsDesign2-package","text":"Maintainer: Keaven Anderson keaven_anderson@merck.com Authors: Yujie Zhao yujie.zhao@merck.com contributors: Merck Sharp & Dohme Corp [copyright holder]","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":null,"dir":"Reference","previous_headings":"","what":"gs_b: Default boundary generation — gs_b","title":"gs_b: Default boundary generation — gs_b","text":"gs_b() simplest version function used upper lower arguments gs_prob(), gs_power_nph gs_design_nph(); simply returns vector input input vector Z , k specified par[k]j returned. Note bounds need change changing information analyses, gs_b() used. instance, spending function bounds use","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"gs_b: Default boundary generation — gs_b","text":"","code":"gs_b(par = NULL, k = NULL, ...)"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"gs_b: Default boundary generation — gs_b","text":"par gs_b(), just Z-values boundaries; can include infinite values k NULL (default), return par, else return par[k] ... arguments passed methods","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"gs_b: Default boundary generation — gs_b","text":"returns vector input par k NULL, otherwise, par[k]","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"gs_b: Default boundary generation — gs_b","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_b.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"gs_b: Default boundary generation — gs_b","text":"","code":"# Simple: enter a vector of length 3 for bound gs_b(par = 4:2) #> [1] 4 3 2  # 2nd element of par gs_b(par = 4:2, k = 2) #> [1] 3  # Generate an efficacy bound using a spending function # Use Lan-DeMets spending approximation of O'Brien-Fleming bound # as 50%, 75% and 100% of final spending # Information fraction IF <- c(.5, .75, 1) gs_b(par = gsDesign::gsDesign(alpha = .025, k = length(IF),       test.type = 1, sfu = gsDesign::sfLDOF,       timing = IF)$upper$bound) #> [1] 2.962588 2.359018 2.014084"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"Group sequential design using average hazard ratio non-proportional hazards","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"","code":"gs_design_ahr(   enrollRates = tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2)/c(9, 18),     hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   ratio = 1,   alpha = 0.025,   beta = 0.1,   IF = NULL,   analysisTimes = 36,   binding = FALSE,   upper = gs_b,   upar = gsDesign::gsDesign(k = 3, test.type = 1, n.I = c(0.25, 0.75, 1), sfu = sfLDOF,     sfupar = NULL)$upper$bound,   lower = gs_b,   lpar = c(qnorm(0.1), -Inf, -Inf),   h1_spending = TRUE,   test_upper = TRUE,   test_lower = TRUE,   info_scale = c(0, 1, 2),   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"enrollRates enrollment rates failRates failure dropout rates ratio Experimental:Control randomization ratio (yet implemented) alpha One-sided Type error beta Type II error Targeted information fraction analysis analysisTimes Minimum time analysis binding indicator whether futility bound binding; default FALSE recommended upper Function compute upper bound upar Parameter passed upper() lower Function compute lower bound lpar Parameter passed lower() h1_spending Indicator lower bound set spending alternate hypothesis (input failRates) spending used lower bound test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default) indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound info_scale information scale calculation r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"tibble columns Analysis, Bound, Z, Probability, theta, Time, AHR, Events","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"Need added","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_ahr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design using average hazard ratio under non-proportional hazards — gs_design_ahr","text":"","code":"library(gsDesign) #> Loading required package: ggplot2 library(gsDesign2) library(dplyr) #>  #> Attaching package: ‘dplyr’ #> The following objects are masked from ‘package:stats’: #>  #>     filter, lag #> The following objects are masked from ‘package:base’: #>  #>     intersect, setdiff, setequal, union  # call with defaults gs_design_ahr() #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  13.2 #> 2 All            2  26.4 #> 3 All           10  39.7 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 1 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <dbl> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper         0.9        0.025  1.96          0.795      0.0250 #>  #> $analysis #> # A tibble: 1 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    36  476.   292. 0.683 0.381  71.7  73.0     1 #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # Single analysis gs_design_ahr(analysisTimes = 40) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  11.9 #> 2 All            2  23.8 #> 3 All           10  35.6 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 1 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <dbl> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper         0.9        0.025  1.96          0.791      0.0250 #>  #> $analysis #> # A tibble: 1 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <dbl> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    40  428.   280. 0.678 0.389  68.8  69.9     1 #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # Multiple analysisTimes gs_design_ahr(analysisTimes = c(12, 24, 36)) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  14.0 #> 2 All            2  27.9 #> 3 All           10  41.9 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 4 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper    0.000507   0.00000848  4.33          0.411  0.00000737 #> 2        1 Lower    0.0111     0.102      -1.28          1.30   0.9        #> 3        2 Upper    0.566      0.00965     2.34          0.734  0.00965    #> 4        3 Upper    0.900      0.0251      2.01          0.795  0.0221     #>  #> $analysis #> # A tibble: 3 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    12  419.   95.0 0.811 0.210  23.4  23.8 0.309 #> 2        2    24  503.  228.  0.715 0.335  55.9  57.1 0.738 #> 3        3    36  503.  308.  0.683 0.381  75.8  77.1 1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # Specified information fraction gs_design_ahr(IF = c(.25, .75, 1), analysisTimes = 36) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  14.2 #> 2 All            2  28.4 #> 3 All           10  42.5 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 4 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper    0.000282   0.00000836  4.33          0.376  0.00000737 #> 2        1 Lower    0.0166     0.101      -1.28          1.34   0.9        #> 3        2 Upper    0.585      0.00965     2.34          0.737  0.00965    #> 4        3 Upper    0.900      0.0250      2.01          0.797  0.0221     #>  #> $analysis #> # A tibble: 3 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  10.7  371.   78.3 0.823 0.195  19.3  19.6 0.251 #> 2        2  24.4  510.  235.  0.714 0.337  57.4  58.7 0.747 #> 3        3  36    510.  313.  0.683 0.381  76.9  78.3 1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # multiple analysis times & IF # driven by times gs_design_ahr(IF = c(.25, .75, 1), analysisTimes = c(12, 25, 36)) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  14.0 #> 2 All            2  27.9 #> 3 All           10  41.9 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 4 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper    0.000507   0.00000848  4.33          0.411  0.00000737 #> 2        1 Lower    0.0111     0.102      -1.28          1.30   0.9        #> 3        2 Upper    0.600      0.00965     2.34          0.738  0.00965    #> 4        3 Upper    0.900      0.0248      2.01          0.795  0.0221     #>  #> $analysis #> # A tibble: 3 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    12  419.   95.0 0.811 0.210  23.4  23.7 0.309 #> 2        2    25  503.  236.  0.711 0.341  57.8  59.1 0.763 #> 3        3    36  503.  308.  0.683 0.381  75.7  77.1 1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"      # driven by IF gs_design_ahr(IF = c(1/3, .8, 1), analysisTimes = c(12, 25, 36)) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  13.9 #> 2 All            2  27.8 #> 3 All           10  41.7 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 4 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper    0.000645   0.00000852  4.33          0.425  0.00000737 #> 2        1 Lower    0.00928    0.102      -1.28          1.29   0.9        #> 3        2 Upper    0.640      0.00965     2.34          0.742  0.00965    #> 4        3 Upper    0.900      0.0244      2.01          0.795  0.0221     #>  #> $analysis #> # A tibble: 3 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  12.5  439.   102. 0.806 0.216  25.2  25.6 0.334 #> 2        2  26.4  501.   246. 0.706 0.348  60.1  61.4 0.797 #> 3        3  36    501.   307. 0.683 0.381  75.4  76.8 1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # 2-sided symmetric design with O'Brien-Fleming spending gs_design_ahr(   analysisTimes = c(12, 24, 36),   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   h1_spending = FALSE) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  13.7 #> 2 All            2  27.5 #> 3 All           10  41.2 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 6 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper 0.00226        0.0000603  3.87          0.449   0.0000538 #> 2        1 Lower 0.000000613    0.0000603 -3.87          2.23    1.00      #> 3        2 Upper 0.550          0.00922    2.36          0.730   0.00919   #> 4        2 Lower 0.00000125     0.00922   -2.36          1.37    0.991     #> 5        3 Upper 0.900          0.0250     2.01          0.794   0.0222    #> 6        3 Lower 0.00000128     0.0250    -2.01          1.26    0.978     #>  #> $analysis #> # A tibble: 3 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    12  412.   93.4 0.811 0.210  23.0  23.3 0.309 #> 2        2    24  494.  224.  0.715 0.335  54.9  56.1 0.738 #> 3        3    36  494.  303.  0.683 0.381  74.4  75.8 1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # 2-sided asymmetric design with O'Brien-Fleming upper spending # Pocock lower spending under H1 (NPH) gs_design_ahr(   analysisTimes = c(12, 24, 36),   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDPocock, total_spend = 0.1, param = NULL, timing = NULL),   h1_spending = TRUE) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2  16.5 #> 2 All            2  32.9 #> 3 All           10  49.4 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 6 × 7 #>   Analysis Bound Probability Probability0      Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl>  <dbl>          <dbl>       <dbl> #> 1        1 Upper     0.00305    0.0000603  3.87           0.481   0.0000538 #> 2        1 Lower     0.0430     0.269     -0.619          1.12    0.732     #> 3        2 Upper     0.638      0.00922    2.36           0.750   0.00920   #> 4        2 Lower     0.0823     0.875      1.13           0.871   0.129     #> 5        3 Upper     0.900      0.0250     1.98           0.813   0.0240    #> 6        3 Lower     0.100      0.976      1.97           0.813   0.0243    #>  #> $analysis #> # A tibble: 3 × 9 #>   Analysis  Time     N Events   AHR theta  info info0    IF #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    12  494.   112. 0.811 0.210  27.6  28.0 0.309 #> 2        2    24  593.   269. 0.715 0.335  65.9  67.3 0.738 #> 3        3    36  593.   364. 0.683 0.381  89.3  90.9 1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design computation with non-constant effect and information — gs_design_npe","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"gs_design_npe() derives group sequential design size, bounds boundary crossing probabilities based proportionate information effect size analyses. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires treatment effect proportionate statistical information analysis well method deriving bounds, spending. routine enables two things available gsDesign package: 1) non-constant effect, 2) flexibility boundary selection. many applications, non-proportional-hazards design function gs_design_nph() used; calls function. Initial bound types supported 1) spending bounds, 2) fixed bounds, 3) Haybittle-Peto-like bounds. requirement boundary update method can bound without knowledge future bounds. example, bounds based conditional power require knowledge future bounds supported routine; limited conditional power method demonstrated. Boundary family designs Wang-Tsiatis designs including original (non-spending-function-based) O'Brien-Fleming Pocock designs supported gs_power_npe().","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"","code":"gs_design_npe(   theta = 0.1,   theta1 = NULL,   info = 1,   info0 = NULL,   info1 = NULL,   info_scale = c(0, 1, 2),   alpha = 0.025,   beta = 0.1,   upper = gs_b,   upar = qnorm(0.975),   lower = gs_b,   lpar = -Inf,   test_upper = TRUE,   test_lower = TRUE,   binding = FALSE,   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"theta natural parameter group sequential design representing expected incremental drift analyses; used power calculation theta1 natural parameter used lower bound spending; NULL, set theta yields usual beta-spending. set 0, spending 2-sided null hypothesis. info proportionate statistical information analyses input theta info0 proportionate statistical information null hypothesis, different alternative; impacts null hypothesis bound calculation info1 proportionate statistical information alternate hypothesis; impacts null hypothesis bound calculation info_scale information scale calculation alpha One-sided Type error beta Type II error upper function compute upper bound upar parameter pass function provided upper lower function compare lower bound lpar Parameter passed function provided lower test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default) indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound binding indicator whether futility bound binding; default FALSE recommended r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"tibble columns Analysis, Bound, Z, Probability,  theta, info, info0","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"inputs info info0 vectors length increasing positive numbers. design returned change constant scale factor ensure design power 1 - beta. bound specifications upper, lower, upar, lpar used ensure Type error boundary properties specified.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"Keaven Anderson keaven_anderson@merck.com","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_npe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design computation with non-constant effect and information — gs_design_npe","text":"","code":"library(dplyr) library(gsDesign)  # ---------------------------------#  #         example 1                # # ---------------------------------#  # Single analysis # Lachin book p 71 difference of proportions example pc <- .28            # Control response rate pe <- .40            # Experimental response rate p0 <- (pc + pe) / 2  # Ave response rate under H0  # Information per increment of 1 in sample size info0 <- 1 / (p0 * (1 - p0) * 4) info <- 1 / (pc * (1 - pc) * 2 + pe * (1 - pe) * 2)  # Result should round up to next even number = 652 # Divide information needed under H1 by information per patient added gs_design_npe(theta = pe - pc, info = info, info0 = info0) #> # A tibble: 1 × 10 #>   Analysis Bound     Z Probability Probability0 theta  info info0 info1    IF #>      <dbl> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  1.96         0.9        0.025  0.12  737.  725.  737.     1   # ---------------------------------#  #         example 2                # # ---------------------------------#  # Fixed bound x <- gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 80,   info0 = (1:3) * 80,   upper = gs_b,   upar = gsDesign::gsDesign(k = 3, sfu = gsDesign::sfLDOF)$upper$bound,   lower = gs_b,   lpar = c(-1, 0, 0)) x #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.00120     0.000104   0.1 0.333  45.6  45.6  45.6 #> 2        1 Lower -1        0.0470      0.159      0.1 0.333  45.6  45.6  45.6 #> 3        2 Upper  2.51     0.273       0.00605    0.2 0.667  91.1  91.1  91.1 #> 4        2 Lower  0        0.0619      0.513      0.2 0.667  91.1  91.1  91.1 #> 5        3 Upper  1.99     0.900       0.0249     0.3 1     137.  137.  137.  #> 6        3 Lower  0        0.0619      0.606      0.3 1     137.  137.  137.   # Same upper bound; this represents non-binding Type I error and will total 0.025 gs_power_npe(   theta = rep(0, 3),   info = (x %>% filter(Bound == \"Upper\"))$info,   upper = gs_b,   upar = (x %>% filter(Bound == \"Upper\"))$Z,   lower = gs_b,   lpar = rep(-Inf, 3)) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71    0.000104     0      0 0.333  45.6  45.6  45.6 #> 2        2 Upper  2.51    0.00605      0      0 0.667  91.1  91.1  91.1 #> 3        3 Upper  1.99    0.0250       0      0 1     137.  137.  137.   # ---------------------------------#  #         example 3                # # ---------------------------------#  # Spending bound examples # Design with futility only at analysis 1; efficacy only at analyses 2, 3 # Spending bound for efficacy; fixed bound for futility # NOTE: test_upper and test_lower DO NOT WORK with gs_b; must explicitly make bounds infinite # test_upper and test_lower DO WORK with gs_spending_bound gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   info0 = (1:3) * 40,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_b,   lpar = c(-1, -Inf, -Inf),   test_upper = c(FALSE, TRUE, TRUE)) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Lower -1         0.0477      0.159     0.1 0.333  44.6  44.6  44.6 #> 2        2 Upper  2.51      0.267       0.00605   0.2 0.667  89.1  89.1  89.1 #> 3        3 Upper  1.99      0.900       0.0249    0.3 1     134.  134.  134.     # one can try `info_scale = 1` or `info_scale = 0` here gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   info0 = (1:3) * 30,   info_scale = 1,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_b,   lpar = c(-1, -Inf, -Inf),   test_upper = c(FALSE, TRUE, TRUE)) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Lower -1         0.0477      0.159     0.1 0.333  44.6  44.6  44.6 #> 2        2 Upper  2.51      0.267       0.00605   0.2 0.667  89.1  89.1  89.1 #> 3        3 Upper  1.99      0.900       0.0249    0.3 1     134.  134.  134.   # ---------------------------------#  #         example 4                # # ---------------------------------#  # Spending function bounds # 2-sided asymmetric bounds # Lower spending based on non-zero effect gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   info0 = (1:3) * 30,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) #> # A tibble: 6 × 10 #>   Analysis Bound      Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr>  <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.000145   0.00000917   0.1 0.333  43.5  32.7  43.5 #> 2        1 Lower -1.34     0.0139     0.0616       0.1 0.333  43.5  32.7  43.5 #> 3        2 Upper  2.51     0.258      0.00595      0.2 0.667  87.1  65.3  87.1 #> 4        2 Lower  0.150    0.0460     0.533        0.2 0.667  87.1  65.3  87.1 #> 5        3 Upper  1.99     0.900      0.0248       0.3 1     131.   98.0 131.  #> 6        3 Lower  2.00     0.0908     0.946        0.3 1     131.   98.0 131.   # ---------------------------------#  #         example 5                # # ---------------------------------#  # Two-sided symmetric spend, O'Brien-Fleming spending # Typically, 2-sided bounds are binding xx <- gs_design_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) xx #> # A tibble: 6 × 10 #>   Analysis Bound      Z Probability Probability0 theta    IF  info info0 info1 #>      <int> <chr>  <dbl>       <dbl>        <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.00104      0.000104   0.1 0.333  39.8  39.8  39.8 #> 2        1 Lower -3.08     0.000104     0.00104    0.1 0.333  39.8  39.8  39.8 #> 3        2 Upper  2.51     0.233        0.00605    0.2 0.667  79.5  79.5  79.5 #> 4        2 Lower -0.728    0.00605      0.233      0.2 0.667  79.5  79.5  79.5 #> 5        3 Upper  1.99     0.900        0.0250     0.3 1     119.  119.  119.  #> 6        3 Lower  1.28     0.0250       0.900      0.3 1     119.  119.  119.   # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upper = gs_b,   lower = gs_b,   upar = (xx %>% filter(Bound == \"Upper\"))$Z,   lpar = -(xx %>% filter(Bound == \"Upper\"))$Z) #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71  0.00104      0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51  0.235        0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99  0.902        0.3    0.3 1       120   120   120 #> 4        1 Lower -3.71  0.00000704   0.1    0.1 0.333    40    40    40 #> 5        2 Lower -2.51  0.0000151    0.2    0.2 0.667    80    80    80 #> 6        3 Lower -1.99  0.0000151    0.3    0.3 1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_wlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design using weighted log-rank test under non-proportional hazards — gs_design_wlr","title":"Group sequential design using weighted log-rank test under non-proportional hazards — gs_design_wlr","text":"Group sequential design using weighted log-rank test non-proportional hazards","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_wlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design using weighted log-rank test under non-proportional hazards — gs_design_wlr","text":"","code":"gs_design_wlr(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   ratio = 1,   weight = wlr_weight_fh,   approx = \"asymptotic\",   alpha = 0.025,   beta = 0.1,   IF = NULL,   analysisTimes = 36,   binding = FALSE,   upper = gs_b,   upar = gsDesign(k = 3, test.type = 1, n.I = c(0.25, 0.75, 1), sfu = sfLDOF, sfupar =     NULL)$upper$bound,   lower = gs_b,   lpar = c(qnorm(0.1), -Inf, -Inf),   h1_spending = TRUE,   test_upper = TRUE,   test_lower = TRUE,   info_scale = c(0, 1, 2),   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_wlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design using weighted log-rank test under non-proportional hazards — gs_design_wlr","text":"enrollRates enrollment rates failRates failure dropout rates ratio Experimental:Control randomization ratio (yet implemented) weight weight weighted log rank test \"1\"=unweighted, \"n\"=Gehan-Breslow, \"sqrtN\"=Tarone-Ware, \"FH_p[]_q[b]\"= Fleming-Harrington p=q=b approx approximate estimation method Z statistics \"event driven\" = work proportional hazard model log rank test \"asymptotic\" alpha One-sided Type error beta Type II error Targeted information fraction analysis analysisTimes Minimum time analysis binding indicator whether futility bound binding; default FALSE recommended upper Function compute upper bound upar Parameter passed upper() lower Function compute lower bound lpar Parameter passed lower() h1_spending Indicator lower bound set spending alternate hypothesis (input failRates) spending used lower bound test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default) indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound info_scale information scale calculation r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_wlr.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential design using weighted log-rank test under non-proportional hazards — gs_design_wlr","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_design_wlr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design using weighted log-rank test under non-proportional hazards — gs_design_wlr","text":"","code":"library(dplyr) library(mvtnorm) library(gsDesign) library(tibble) library(gsDesign2)  # set enrollment rates enrollRates <- tibble(Stratum = \"All\", duration = 12, rate = 500/12)  # set failure rates failRates <- tibble(   Stratum = \"All\",   duration = c(4, 100),   failRate = log(2) / 15,  # median survival 15 month   hr = c(1, .6),   dropoutRate = 0.001)  # -------------------------# #       example 1          # # ------------------------ # # Boundary is fixed  x <- gsSurv(   k = 3,    test.type = 4,    alpha = 0.025, beta = 0.2,    astar = 0, timing = 1,   sfu = sfLDOF, sfupar = 0,    sfl = sfLDOF, sflpar = 0,    lambdaC = 0.1,    hr = 0.6, hr0 = 1,    eta = 0.01, gamma = 10,   R = 12, S = NULL,   T = 36, minfup = 24,    ratio = 1)  gs_design_wlr(   enrollRates = enrollRates,    failRates = failRates,   ratio = 1,    alpha = 0.025, beta = 0.2,   weight = function(x, arm0, arm1){wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0.5)},   upper = gs_b,   upar = x$upper$bound,   lower = gs_b,   lpar = x$lower$bound,   analysisTimes = c(12, 24, 36)) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\"  # -------------------------# #       example 2          # # ------------------------ # # Boundary derived by spending function gs_design_wlr(   enrollRates = enrollRates,    failRates = failRates,   ratio = 1,    alpha = 0.025, beta = 0.2,   weight = function(x, arm0, arm1){wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0.5)},   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2),   analysisTimes = c(12, 24, 36)) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":null,"dir":"Reference","previous_headings":"","what":"Information and effect size based on AHR approximation — gs_info_ahr","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"Based piecewise enrollment rate, failure rate, dropout rates computes approximate information effect size using average hazard ratio model.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"","code":"gs_info_ahr(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   ratio = 1,   events = NULL,   analysisTimes = NULL )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"enrollRates enrollment rates failRates failure dropout rates ratio Experimental:Control randomization ratio events Targeted minimum events analysis analysisTimes Targeted minimum study duration analysis","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"tibble columns Analysis, Time, AHR, Events, theta, info, info0. info, info0 contains statistical information H1, H0, respectively. analysis k, Time[k] maximum analysisTimes[k] expected time required accrue targeted events[k]. AHR expected average hazard ratio analysis.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"AHR() function computes statistical information targeted event times. tEvents() function used get events average HR targeted analysisTimes.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_ahr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Information and effect size based on AHR approximation — gs_info_ahr","text":"","code":"library(gsDesign) library(gsDesign2)  # ------------------------ # #       Example 1          # # ------------------------ # # Only put in targeted events gs_info_ahr(events = c(30, 40, 50)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  14.9   30.0 0.787 0.240  7.37  7.50 #> 2        2  19.2   40.0 0.744 0.295  9.79 10.0  #> 3        3  24.5   50.0 0.713 0.339 12.2  12.5   # ------------------------ # #       Example 2          # # ------------------------ # # Only put in targeted analysis times gs_info_ahr(analysisTimes = c(18, 27, 36)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    18   37.6 0.755 0.282  9.21  9.40 #> 2        2    27   54.0 0.704 0.351 13.2  13.5  #> 3        3    36   66.2 0.683 0.381 16.3  16.6   # ------------------------ # #       Example 3          # # ------------------------ # # Some analysis times after time at which targeted events accrue # Check that both Time >= input analysisTime and Events >= input events gs_info_ahr(events = c(30, 40, 50), analysisTimes = c(16, 19, 26)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  16     33.1 0.776 0.254  8.12  8.27 #> 2        2  19.2   40.0 0.744 0.295  9.79 10.0  #> 3        3  26     52.4 0.707 0.346 12.8  13.1  gs_info_ahr(events = c(30, 40, 50), analysisTimes = c(14, 20, 24)) #> # A tibble: 3 × 7 #>   Analysis  Time Events   AHR theta  info info0 #>      <int> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  14.9   30.0 0.787 0.240  7.37  7.50 #> 2        2  20     41.7 0.738 0.304 10.2  10.4  #> 3        3  24.5   50.0 0.713 0.339 12.2  12.5"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_wlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Information and effect size for Weighted Log-rank test — gs_info_wlr","title":"Information and effect size for Weighted Log-rank test — gs_info_wlr","text":"Based piecewise enrollment rate, failure rate, dropout rates computes approximate information effect size using average hazard ratio model.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_wlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Information and effect size for Weighted Log-rank test — gs_info_wlr","text":"","code":"gs_info_wlr(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6,     9)),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   ratio = 1,   events = NULL,   analysisTimes = NULL,   weight = wlr_weight_fh,   approx = \"asymptotic\" )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_wlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Information and effect size for Weighted Log-rank test — gs_info_wlr","text":"enrollRates enrollment rates failRates failure dropout rates ratio Experimental:Control randomization ratio events Targeted minimum events analysis analysisTimes Targeted minimum study duration analysis weight weight weighted log rank test \"1\"=unweighted, \"n\"=Gehan-Breslow, \"sqrtN\"=Tarone-Ware, \"FH_p[]_q[b]\"= Fleming-Harrington p=q=b approx approximate estimation method Z statistics \"event driven\" = work proportional hazard model log rank test \"asymptotic\"","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_wlr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Information and effect size for Weighted Log-rank test — gs_info_wlr","text":"tibble columns Analysis, Time, N, Events, AHR, delta, sigma2, theta, info, info0. info, info0 contains statistical information H1, H0, respectively. analysis k, Time[k] maximum analysisTimes[k] expected time required accrue targeted events[k]. AHR expected average hazard ratio analysis.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_info_wlr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Information and effect size for Weighted Log-rank test — gs_info_wlr","text":"AHR() function computes statistical information targeted event times. tEvents() function used get events average HR targeted analysisTimes.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"Group sequential design power using average hazard ratio non-proportional hazards","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"","code":"gs_power_ahr(   enrollRates = tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2)/c(9, 18),     hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   events = c(30, 40, 50),   analysisTimes = NULL,   upper = gs_b,   lower = gs_b,   upar = gsDesign(k = length(events), test.type = 1, n.I = events, maxn.IPlan =     max(events), sfu = sfLDOF, sfupar = NULL)$upper$bound,   lpar = c(qnorm(0.1), rep(-Inf, 2)),   test_lower = TRUE,   test_upper = TRUE,   ratio = 1,   binding = FALSE,   info_scale = c(0, 1, 2),   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"enrollRates enrollment rates failRates failure dropout rates events Targeted events analysis analysisTimes Minimum time analysis upper Function compute upper bound lower Function compute lower bound upar Parameter passed upper() lpar Parameter passed lower() test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default) indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound ratio Experimental:Control randomization ratio (yet implemented) binding indicator whether futility bound binding; default FALSE recommended info_scale information scale calculation r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"tibble columns Analysis, Bound, Z, Probability, theta, Time, AHR, Events. Contains row analysis bound.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"Bound satisfy input upper bound specification upper, upar lower bound specification lower, lpar. AHR() function computes statistical information targeted event times. tEvents() function used get events average HR targeted analysisTimes.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_ahr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design power using average hazard ratio under non-proportional hazards — gs_power_ahr","text":"","code":"library(gsDesign2) library(dplyr)  # -------------------------# #       example 1          # # ------------------------ # # The default output of \\code{gs_power_ahr} is driven by events, i.e., # \\code{events = c(30, 40, 50), analysisTimes = NULL} gs_power_ahr()  #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2     3 #> 2 All            2     6 #> 3 All           10     9 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 4 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper      0.0231      0.00381  2.67          0.377     0.00381 #> 2        1 Lower      0.0273      0.100   -1.28          1.60      0.9     #> 3        2 Upper      0.0897      0.0122   2.29          0.485     0.0110  #> 4        3 Upper      0.207       0.0250   2.03          0.563     0.0211  #>  #> $analysis #> # A tibble: 3 × 10 #>   Analysis  Time     N Events   AHR theta  info info0    IF   IF0 #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  14.9   108   30.0 0.787 0.240  7.37  7.50 0.603 0.600 #> 2        2  19.2   108   40.0 0.744 0.295  9.79 10.0  0.801 0.800 #> 3        3  24.5   108   50.0 0.713 0.339 12.2  12.5  1     1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # -------------------------# #       example 2          # # -------------------------# # 2-sided symmetric O'Brien-Fleming spending bound,  # driven by analysis time, i.e., \\code{events = NULL, analysisTimes = c(12, 24, 36)} gs_power_ahr(   analysisTimes = c(12, 24, 36),   events = NULL,   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))  #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2     3 #> 2 All            2     6 #> 3 All           10     9 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 6 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper   0.000370     0.0000538  3.87          0.180   0.0000538 #> 2        1 Lower   0.0000612    0.0000554 -3.87          5.54    1.00      #> 3        2 Upper   0.116        0.00921    2.36          0.510   0.00919   #> 4        2 Lower   0.00907      0.00906   -2.36          1.96    0.991     #> 5        3 Upper   0.324        0.0250     2.01          0.610   0.0222    #> 6        3 Lower   0.0250       0.0250    -2.01          1.64    0.978     #>  #> $analysis #> # A tibble: 3 × 10 #>   Analysis  Time     N Events   AHR theta  info info0    IF   IF0 #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1    12    90   20.4 0.811 0.210  5.03  5.10 0.309 0.308 #> 2        2    24   108   49.1 0.715 0.335 12.0  12.3  0.738 0.741 #> 3        3    36   108   66.2 0.683 0.381 16.3  16.6  1     1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # -------------------------# #       example 3          # # -------------------------# # 2-sided symmetric O'Brien-Fleming spending bound, # driven by events, i.e., \\code{events = c(20, 50, 70), analysisTimes = NULL} gs_power_ahr(   analysisTimes = NULL,   events = c(20, 50, 70),   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2     3 #> 2 All            2     6 #> 3 All           10     9 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 6 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper   0.000198     0.0000275  4.03          0.165   0.0000275 #> 2        1 Lower   0.0000312    0.0000280 -4.03          6.06    1.00      #> 3        2 Upper   0.110        0.00800    2.41          0.506   0.00799   #> 4        2 Lower   0.00782      0.00782   -2.42          1.98    0.992     #> 5        3 Upper   0.352        0.0250     2.00          0.619   0.0226    #> 6        3 Lower   0.0250       0.0250    -2.00          1.61    0.977     #>  #> $analysis #> # A tibble: 3 × 10 #>   Analysis  Time     N Events   AHR theta  info info0    IF   IF0 #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  11.9  88.8   20.0 0.812 0.208  4.93  5.00 0.286 0.286 #> 2        2  24.5 108     50.0 0.713 0.339 12.2  12.5  0.710 0.714 #> 3        3  39.4 108     70.0 0.679 0.388 17.2  17.5  1     1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\"       # -------------------------# #       example 4          # # -------------------------# # 2-sided symmetric O'Brien-Fleming spending bound, # driven by both `events` and `analysisTimes`, i.e., # both `events` and `analysisTimes` are not `NULL`, # then the analysis will driven by the maximal one, i.e., # Time = max(analysisTime, calculated Time for targeted events) # Events = max(events, calculated events for targeted analysisTime) gs_power_ahr(   analysisTimes = c(12, 24, 36),   events = c(30, 40, 50),   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL)) #> $enrollRates #> # A tibble: 3 × 3 #>   Stratum duration  rate #>   <chr>      <dbl> <dbl> #> 1 All            2     3 #> 2 All            2     6 #> 3 All           10     9 #>  #> $failRates #> # A tibble: 2 × 5 #>   Stratum duration failRate    hr dropoutRate #>   <chr>      <dbl>    <dbl> <dbl>       <dbl> #> 1 All            3   0.0770   0.9       0.001 #> 2 All          100   0.0385   0.6       0.001 #>  #> $bounds #> # A tibble: 6 × 7 #>   Analysis Bound Probability Probability0     Z `~HR at bound` `Nominal p` #>      <int> <chr>       <dbl>        <dbl> <dbl>          <dbl>       <dbl> #> 1        1 Upper    0.00706      0.000867  3.13          0.319    0.000867 #> 2        1 Lower    0.000935     0.000871 -3.13          3.14     0.999    #> 3        2 Upper    0.115        0.00921   2.37          0.508    0.00892  #> 4        2 Lower    0.00912      0.00906  -2.38          1.97     0.991    #> 5        3 Upper    0.324        0.0250    2.01          0.610    0.0222   #> 6        3 Lower    0.0251       0.0250   -2.01          1.64     0.978    #>  #> $analysis #> # A tibble: 3 × 10 #>   Analysis  Time     N Events   AHR theta  info info0    IF   IF0 #>      <int> <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1  14.9   108   30.0 0.787 0.240  7.37  7.50 0.453 0.453 #> 2        2  24     108   49.1 0.715 0.335 12.0  12.3  0.738 0.741 #> 3        3  36     108   66.2 0.683 0.381 16.3  16.6  1     1     #>  #> attr(,\"class\") #> [1] \"ahr\"       \"gs_design\" \"list\""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential bound computation with non-constant effect — gs_power_npe","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"gs_power_npe() derives group sequential bounds boundary crossing probabilities design. allows non-constant treatment effect time, also can applied usual homogeneous effect size designs. requires treatment effect statistical information analysis well method deriving bounds, spending. routine enables two things available gsDesign package: 1) non-constant effect, 2) flexibility boundary selection. many applications, non-proportional-hazards design function gs_design_nph() used; calls function. Initial bound types supported 1) spending bounds, 2) fixed bounds, 3) Haybittle-Peto-like bounds. requirement boundary update method can bound without knowledge future bounds. example, bounds based conditional power require knowledge future bounds supported routine; limited conditional power method demonstrated. Boundary family designs Wang-Tsiatis designs including original (non-spending-function-based) O'Brien-Fleming Pocock designs supported gs_power_npe().","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"","code":"gs_power_npe(   theta = 0.1,   theta1 = NULL,   info = 1,   info0 = NULL,   info1 = NULL,   info_scale = c(0, 1, 2),   binding = FALSE,   upper = gs_b,   upar = qnorm(0.975),   lower = gs_b,   lpar = -Inf,   test_upper = TRUE,   test_lower = TRUE,   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"theta natural parameter group sequential design representing expected incremental drift analyses; used power calculation theta1 natural parameter alternate hypothesis, needed lower bound computation info statistical information analyses input theta info0 statistical information null hypothesis, different info; impacts null hypothesis bound calculation info1 statistical information hypothesis used futility bound calculation different info; impacts futility hypothesis bound calculation info_scale information scale calculation binding indicator whether futility bound binding; default FALSE recommended upper function compute upper bound upar parameter pass upper lower function compare lower bound lpar parameter pass lower test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default)  indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"Keaven Anderson keaven_anderson@merck.com","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_npe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential bound computation with non-constant effect — gs_power_npe","text":"","code":"library(gsDesign) library(gsDesign2) library(dplyr)  # Default (single analysis; Type I error controlled) gs_power_npe(theta = 0) %>% filter(Bound == \"Upper\") #> # A tibble: 1 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  1.96      0.0250     0      0     1     1     1     1  # Fixed bound gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,    upper = gs_b,    upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,   lower = gs_b,    lpar =  c(-1, 0, 0)) #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71     0.00104   0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51     0.235     0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99     0.869     0.3    0.3 1       120   120   120 #> 4        1 Lower -1        0.0513    0.1    0.1 0.333    40    40    40 #> 5        2 Lower  0        0.0715    0.2    0.2 0.667    80    80    80 #> 6        3 Lower  0        0.0715    0.3    0.3 1       120   120   120  # Same fixed efficacy bounds, no futility bound (i.e., non-binding bound), null hypothesis gs_power_npe(   theta = rep(0, 3),    info = (1:3) * 40,   upar = gsDesign::gsDesign(k = 3,sfu = gsDesign::sfLDOF)$upper$bound,   lpar = rep(-Inf, 3)) %>%    filter(Bound == \"Upper\") #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71    0.000104     0      0 0.333    40    40    40 #> 2        2 Upper  2.51    0.00605      0      0 0.667    80    80    80 #> 3        3 Upper  1.99    0.0250       0      0 1       120   120   120  # Fixed bound with futility only at analysis 1; efficacy only at analyses 2, 3 gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,   upper = gs_b,   upar = c(Inf, 3, 2),    lower = gs_b,   lpar = c(qnorm(.1), -Inf, -Inf)) #> # A tibble: 3 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        2 Upper  3         0.113    0.2    0.2 0.667    80    80    80 #> 2        3 Upper  2         0.887    0.3    0.3 1       120   120   120 #> 3        1 Lower -1.28      0.0278   0.1    0.1 0.333    40    40    40  # Spending function bounds # Lower spending based on non-zero effect gs_power_npe(   theta = c(.1, .2, .3),    info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) #> # A tibble: 6 × 10 #>   Analysis Bound       Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr>   <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71       0.00104   0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51       0.235     0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99       0.883     0.3    0.3 1       120   120   120 #> 4        1 Lower -1.36       0.0230    0.1    0.1 0.333    40    40    40 #> 5        2 Lower  0.0726     0.0552    0.2    0.2 0.667    80    80    80 #> 6        3 Lower  1.86       0.100     0.3    0.3 1       120   120   120  # Same bounds, but power under different theta gs_power_npe(   theta = c(.15, .25, .35),    info = (1:3) * 40,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfHSD, total_spend = 0.1, param = -1, timing = NULL)) #> # A tibble: 6 × 10 #>   Analysis Bound      Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr>  <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71      0.00288  0.15   0.15 0.333    40    40    40 #> 2        2 Upper  2.51      0.391    0.25   0.25 0.667    80    80    80 #> 3        3 Upper  1.99      0.931    0.35   0.35 1       120   120   120 #> 4        1 Lower -1.05      0.0230   0.15   0.15 0.333    40    40    40 #> 5        2 Lower  0.520     0.0552   0.25   0.25 0.667    80    80    80 #> 6        3 Lower  2.41      0.100    0.35   0.35 1       120   120   120  # Two-sided symmetric spend, O'Brien-Fleming spending # Typically, 2-sided bounds are binding x <- gs_power_npe(   theta = rep(0, 3),    info = (1:3) * 40,   binding = TRUE,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL))  # Re-use these bounds under alternate hypothesis # Always use binding = TRUE for power calculations gs_power_npe(   theta = c(.1, .2, .3),   info = (1:3) * 40,   binding = TRUE,   upar = (x %>% filter(Bound == \"Upper\"))$Z,   lpar = -(x %>% filter(Bound == \"Upper\"))$Z) #> # A tibble: 6 × 10 #>   Analysis Bound     Z Probability theta theta1    IF  info info0 info1 #>      <int> <chr> <dbl>       <dbl> <dbl>  <dbl> <dbl> <dbl> <dbl> <dbl> #> 1        1 Upper  3.71  0.00104      0.1    0.1 0.333    40    40    40 #> 2        2 Upper  2.51  0.235        0.2    0.2 0.667    80    80    80 #> 3        3 Upper  1.99  0.902        0.3    0.3 1       120   120   120 #> 4        1 Lower -3.71  0.00000704   0.1    0.1 0.333    40    40    40 #> 5        2 Lower -2.51  0.0000151    0.2    0.2 0.667    80    80    80 #> 6        3 Lower -1.99  0.0000151    0.3    0.3 1       120   120   120"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_wlr.html","id":null,"dir":"Reference","previous_headings":"","what":"Group sequential design power using weighted log rank test under non-proportional hazards — gs_power_wlr","title":"Group sequential design power using weighted log rank test under non-proportional hazards — gs_power_wlr","text":"Group sequential design power using weighted log rank test non-proportional hazards","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_wlr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Group sequential design power using weighted log rank test under non-proportional hazards — gs_power_wlr","text":"","code":"gs_power_wlr(   enrollRates = tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9)),   failRates = tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2)/c(9, 18),     hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   events = c(30, 40, 50),   analysisTimes = NULL,   binding = FALSE,   upper = gs_b,   lower = gs_b,   upar = gsDesign(k = 3, test.type = 1, n.I = c(30, 40, 50), maxn.IPlan = 50, sfu =     sfLDOF, sfupar = NULL)$upper$bound,   lpar = c(qnorm(0.1), rep(-Inf, length(events) - 1)),   test_upper = TRUE,   test_lower = TRUE,   ratio = 1,   weight = wlr_weight_fh,   info_scale = c(0, 1, 2),   approx = \"asymptotic\",   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_wlr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Group sequential design power using weighted log rank test under non-proportional hazards — gs_power_wlr","text":"enrollRates enrollment rates failRates failure dropout rates events Targeted events analysis analysisTimes Minimum time analysis binding indicator whether futility bound binding; default FALSE recommended upper Function compute upper bound lower Function compute lower bound upar Parameter passed upper() lpar Parameter passed lower() test_upper indicator analyses include upper (efficacy) bound; single value TRUE (default) indicates analyses; otherwise, logical vector length info indicate analyses efficacy bound test_lower indicator analyses include lower bound; single value TRUE (default) indicates analyses; single value FALSE indicated lower bound; otherwise, logical vector length info indicate analyses lower bound ratio Experimental:Control randomization ratio (yet implemented) weight weight weighted log rank test \"1\"=unweighted, \"n\"=Gehan-Breslow, \"sqrtN\"=Tarone-Ware, \"FH_p[]_q[b]\"= Fleming-Harrington p=q=b info_scale information scale calculation approx approximate estimation method Z statistics \"event driven\" = work proportional hazard model log rank test \"asymptotic\" r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter boundary convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_wlr.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Group sequential design power using weighted log rank test under non-proportional hazards — gs_power_wlr","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_power_wlr.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Group sequential design power using weighted log rank test under non-proportional hazards — gs_power_wlr","text":"","code":"library(tibble) library(gsDesign) library(gsDesign2)  # set enrollment rates enrollRates <- tibble(Stratum = \"All\", duration = 12, rate = 500/12)  # set failure rates failRates <- tibble(   Stratum = \"All\",   duration = c(4, 100),   failRate = log(2) / 15,  # median survival 15 month   hr = c(1, .6),   dropoutRate = 0.001)    # set the targeted number of events and analysis time target_events <- c(30, 40, 50) target_analysisTime <- c(10, 24, 30)  # -------------------------# #       example 1          # # ------------------------ # # fixed bounds and calculate the power for targeted number of events gs_power_wlr(   enrollRates = enrollRates,   failRates = failRates,   events = target_events,   analysisTimes = NULL,   upper = gs_b,   upar = gsDesign(k = length(target_events), test.type = 1, n.I = target_events, maxn.IPlan = max(target_events), sfu = sfLDOF, sfupar = NULL)$upper$bound,   lower = gs_b,   lpar = c(qnorm(.1), rep(-Inf, length(events) - 1))) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\"    # -------------------------# #       example 2          # # ------------------------ # # fixed bounds and calculate the power for targeted analysis time gs_power_wlr(   enrollRates = enrollRates,   failRates = failRates,   events = NULL,   analysisTimes = target_analysisTime,   upper = gs_b,   upar = gsDesign(k = length(target_events), test.type = 1, n.I = target_events, maxn.IPlan = max(target_events), sfu = sfLDOF, sfupar = NULL)$upper$bound,   lower = gs_b,   lpar = c(qnorm(.1), rep(-Inf, length(events) - 1))) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\"  # -------------------------# #       example 3          # # ------------------------ # # fixed bounds and calculate the power for targeted analysis time & number of events gs_power_wlr(   enrollRates = enrollRates,   failRates = failRates,   events = target_events,   analysisTimes = target_analysisTime,   upper = gs_b,   upar = gsDesign(k = length(target_events), test.type = 1, n.I = target_events, maxn.IPlan = max(target_events), sfu = sfLDOF, sfupar = NULL)$upper$bound,   lower = gs_b,   lpar = c(qnorm(.1), rep(-Inf, length(events) - 1))) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\"    # -------------------------# #       example 4          # # ------------------------ # # spending bounds and calculate the power for targeted number of events gs_power_wlr(   enrollRates = enrollRates,   failRates = failRates,   events = target_events,   analysisTimes = NULL,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\"    # -------------------------# #       example 5          # # ------------------------ # # spending bounds and calculate the power for targeted analysis time gs_power_wlr(   enrollRates = enrollRates,   failRates = failRates,   events = NULL,   analysisTimes = target_analysisTime,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\"    # -------------------------# #       example 6          # # ------------------------ # # spending bounds and calculate the power for targeted analysis time & number of events gs_power_wlr(   enrollRates = enrollRates,   failRates = failRates,   events = target_events,   analysisTimes = target_analysisTime,   upper = gs_spending_bound,   upar = list(sf = gsDesign::sfLDOF, total_spend = 0.025),   lower = gs_spending_bound,   lpar = list(sf = gsDesign::sfLDOF, total_spend = 0.2)) #> Error in gs_create_arm(enrollRates, failRates, ratio): could not find function \"gs_create_arm\""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":null,"dir":"Reference","previous_headings":"","what":"Derive spending bound for group sequential boundary — gs_spending_bound","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"Computes one bound time based spending given distributional assumptions. user specifies gs_spending_bound() use functions, intended use . important user specifications made list provided functions using gs_spending_bound(). Function uses numerical integration Newton-Raphson iteration derive individual bound group sequential design satisfies targeted boundary crossing probability. Algorithm simple extension Chapter 19 Jennison Turnbull (2000).","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"","code":"gs_spending_bound(   k = 1,   par = list(sf = gsDesign::sfLDOF, total_spend = 0.025, param = NULL, timing = NULL,     max_info = NULL),   hgm1 = NULL,   theta = 0.1,   info = 1:3,   efficacy = TRUE,   test_bound = TRUE,   r = 18,   tol = 1e-06 )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"k analysis bound computed par list following items: sf (class spending function), total_spend (total spend), param (parameters needed spending function sf()), timing (vector containing values spending function evaluated NULL information-based spending used), max_info (timing NULL, can input positive number used info information fraction analysis) hgm1 subdensity grid h1 (k=2) hupdate (k>2) analysis k-1; k=1, used may NULL theta natural parameter used lower bound spending; represents average drift time analysis least analysis k; upper bound spending always set null hypothesis (theta = 0) info statistical information analyses, least analysis k efficacy TRUE (default) efficacy bound, FALSE otherwise test_bound logical vector length info indicate analyses bound r Integer, least 2; default 18 recommended Jennison Turnbull tol Tolerance parameter convergence (Z-scale)","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"returns numeric bound (possibly infinite) , upon failure, generates error message.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"contents section shown PDF user manual .","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"Jennison C Turnbull BW (2000), Group Sequential Methods Applications Clinical Trials. Boca Raton: Chapman Hall.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/gs_spending_bound.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"Derive spending bound for group sequential boundary — gs_spending_bound","text":"Keaven Anderson keaven_anderson@merck.com","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":null,"dir":"Reference","previous_headings":"","what":"Predict time at which a targeted event count is achieved — tEvents","title":"Predict time at which a targeted event count is achieved — tEvents","text":"tEvents() made match input format AHR() solve time expected accumulated events equal input target. Enrollment failure rate distributions specified follows. piecewise exponential distribution allows simple method specify distribtuion enrollment pattern enrollment, failure dropout rates changes time.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Predict time at which a targeted event count is achieved — tEvents","text":"","code":"tEvents(   enrollRates = tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9)     * 5),   failRates = tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate =     log(2)/c(9, 18), hr = c(0.9, 0.6), dropoutRate = rep(0.001, 2)),   targetEvents = 150,   ratio = 1,   interval = c(0.01, 100) )"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Predict time at which a targeted event count is achieved — tEvents","text":"enrollRates Piecewise constant enrollment rates stratum time period. failRates Piecewise constant control group failure rates, duration piecewise constant period, hazard ratio experimental vs control, dropout rates stratum time period. targetEvents targeted number events achieved. ratio Experimental:Control randomization ratio. interval interval presumed include time expected event count equal targetEvents.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Predict time at which a targeted event count is achieved — tEvents","text":"tibble Time (computed match events targetEvents), AHR (average hazard ratio), Events (targetEvents input), info (information given scenarios), info0 (information related null hypothesis) value totalDuration input;","code":""},{"path":[]},{"path":"https://littlebeannie.github.io/gsDesign2/reference/tEvents.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Predict time at which a targeted event count is achieved — tEvents","text":"","code":"# ------------------------#  #      Example 1          # # ------------------------# # default tEvents() #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1  14.9 0.787   150.  36.9  37.5  # ------------------------#  #      Example 2          # # ------------------------# # check that result matches a finding using AHR() # Start by deriving an expected event count enrollRates <- tibble::tibble(Stratum = \"All\", duration = c(2, 2, 10), rate = c(3, 6, 9) * 5) failRates <- tibble::tibble(Stratum = \"All\", duration = c(3, 100), failRate = log(2) / c(9, 18),                              hr = c(.9,.6), dropoutRate = rep(.001, 2)) totalDuration <- 20 xx <- AHR(enrollRates, failRates, totalDuration) xx #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1    20 0.738   208.  51.0  52.1  # Next we check that the function confirms the timing of the final analysis. tEvents(enrollRates, failRates,          targetEvents = xx$Events, interval = c(.5, 1.5) * xx$Time) #> # A tibble: 1 × 5 #>    Time   AHR Events  info info0 #>   <dbl> <dbl>  <dbl> <dbl> <dbl> #> 1  20.0 0.738   208.  51.0  52.1"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/wlr_weight.html","id":null,"dir":"Reference","previous_headings":"","what":"Weight Function of Weighted Log-rank Test — wlr_weight","title":"Weight Function of Weighted Log-rank Test — wlr_weight","text":"wlr_weight_fh Fleming-Harriongton, FH(rho, gamma) weight function. wlr_weight_1  constant log rank test wlr_weight_power Gehan-Breslow Tarone-Ware weight function.","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/wlr_weight.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Weight Function of Weighted Log-rank Test — wlr_weight","text":"","code":"wlr_weight_fh(x, arm0, arm1, rho = 0, gamma = 0, tau = NULL)  wlr_weight_1(x, arm0, arm1)  wlr_weight_n(x, arm0, arm1, power = 1)"},{"path":"https://littlebeannie.github.io/gsDesign2/reference/wlr_weight.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Weight Function of Weighted Log-rank Test — wlr_weight","text":"x analysis time arm0 \"arm\" object defined npsurvSS package arm1 \"arm\" object defined npsurvSS package rho scalar parameter controls type test gamma scalar parameter controls type test tau scalar parameter cut-time modest weighted log rank test power scalar parameter controls power weight function","code":""},{"path":"https://littlebeannie.github.io/gsDesign2/reference/wlr_weight.html","id":"specification","dir":"Reference","previous_headings":"","what":"Specification","title":"Weight Function of Weighted Log-rank Test — wlr_weight","text":"contents section shown PDF user manual .","code":""}]
